; Listing generated by Microsoft (R) Optimizing Compiler Version 12.00.9044.0 

	TITLE	F:\zdoom\zdoom-2.0\src\oplsynth\fmopl.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ?OPL_STATUS_SET@@YIXPAUfm_opl_f@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OPL_STATUS_RESET@@YIXPAUfm_opl_f@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OPL_STATUSMASK_SET@@YIXPAUfm_opl_f@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?op_calc@@YIHIIHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?op_calc1@@YIHIIHI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FM_KEYON@@YIXPAUOPL_SLOT@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FM_KEYOFF@@YIXPAUOPL_SLOT@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?set_ar_dr@@YIXPAUfm_opl_f@@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CSMKeyControll@@YIXPAUOPL_CH@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
_YM3812NumChips DD 01H DUP (?)
_num_lock DD	01H DUP (?)
_cur_chip DD	01H DUP (?)
_BSS	ENDS
CONST	SEGMENT
_slot_array DD	00H
	DD	02H
	DD	04H
	DD	01H
	DD	03H
	DD	05H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	06H
	DD	08H
	DD	0aH
	DD	07H
	DD	09H
	DD	0bH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0cH
	DD	0eH
	DD	010H
	DD	0dH
	DD	0fH
	DD	011H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
_ksl_tab DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	08H
	DD	0cH
	DD	010H
	DD	014H
	DD	018H
	DD	01cH
	DD	020H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0cH
	DD	014H
	DD	01cH
	DD	020H
	DD	028H
	DD	02cH
	DD	030H
	DD	034H
	DD	038H
	DD	03cH
	DD	040H
	DD	00H
	DD	00H
	DD	00H
	DD	014H
	DD	020H
	DD	02cH
	DD	034H
	DD	03cH
	DD	040H
	DD	048H
	DD	04cH
	DD	050H
	DD	054H
	DD	058H
	DD	05cH
	DD	060H
	DD	00H
	DD	00H
	DD	020H
	DD	034H
	DD	040H
	DD	04cH
	DD	054H
	DD	05cH
	DD	060H
	DD	068H
	DD	06cH
	DD	070H
	DD	074H
	DD	078H
	DD	07cH
	DD	080H
	DD	00H
	DD	020H
	DD	040H
	DD	054H
	DD	060H
	DD	06cH
	DD	074H
	DD	07cH
	DD	080H
	DD	088H
	DD	08cH
	DD	090H
	DD	094H
	DD	098H
	DD	09cH
	DD	0a0H
	DD	00H
	DD	040H
	DD	060H
	DD	074H
	DD	080H
	DD	08cH
	DD	094H
	DD	09cH
	DD	0a0H
	DD	0a8H
	DD	0acH
	DD	0b0H
	DD	0b4H
	DD	0b8H
	DD	0bcH
	DD	0c0H
	DD	00H
	DD	060H
	DD	080H
	DD	094H
	DD	0a0H
	DD	0acH
	DD	0b4H
	DD	0bcH
	DD	0c0H
	DD	0c8H
	DD	0ccH
	DD	0d0H
	DD	0d4H
	DD	0d8H
	DD	0dcH
	DD	0e0H
_sl_tab	DD	00H
	DD	010H
	DD	020H
	DD	030H
	DD	040H
	DD	050H
	DD	060H
	DD	070H
	DD	080H
	DD	090H
	DD	0a0H
	DD	0b0H
	DD	0c0H
	DD	0d0H
	DD	0e0H
	DD	01f0H
_eg_inc	DB	00H
	DB	01H
	DB	00H
	DB	01H
	DB	00H
	DB	01H
	DB	00H
	DB	01H
	DB	00H
	DB	01H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	01H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	02H
	DB	01H
	DB	01H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	04H
	DB	02H
	DB	02H
	DB	02H
	DB	04H
	DB	02H
	DB	04H
	DB	02H
	DB	04H
	DB	02H
	DB	04H
	DB	02H
	DB	04H
	DB	02H
	DB	04H
	DB	04H
	DB	04H
	DB	02H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
_eg_rate_select DB 070H
	DB	070H
	DB	070H
	DB	070H
	DB	070H
	DB	070H
	DB	070H
	DB	070H
	DB	070H
	DB	070H
	DB	070H
	DB	070H
	DB	070H
	DB	070H
	DB	070H
	DB	070H
	DB	00H
	DB	08H
	DB	010H
	DB	018H
	DB	00H
	DB	08H
	DB	010H
	DB	018H
	DB	00H
	DB	08H
	DB	010H
	DB	018H
	DB	00H
	DB	08H
	DB	010H
	DB	018H
	DB	00H
	DB	08H
	DB	010H
	DB	018H
	DB	00H
	DB	08H
	DB	010H
	DB	018H
	DB	00H
	DB	08H
	DB	010H
	DB	018H
	DB	00H
	DB	08H
	DB	010H
	DB	018H
	DB	00H
	DB	08H
	DB	010H
	DB	018H
	DB	00H
	DB	08H
	DB	010H
	DB	018H
	DB	00H
	DB	08H
	DB	010H
	DB	018H
	DB	00H
	DB	08H
	DB	010H
	DB	018H
	DB	00H
	DB	08H
	DB	010H
	DB	018H
	DB	020H
	DB	028H
	DB	030H
	DB	038H
	DB	040H
	DB	048H
	DB	050H
	DB	058H
	DB	060H
	DB	060H
	DB	060H
	DB	060H
	DB	060H
	DB	060H
	DB	060H
	DB	060H
	DB	060H
	DB	060H
	DB	060H
	DB	060H
	DB	060H
	DB	060H
	DB	060H
	DB	060H
	DB	060H
	DB	060H
	DB	060H
	DB	060H
_eg_rate_shift DB 00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
_mul_tab DB	01H
	DB	02H
	DB	04H
	DB	06H
	DB	08H
	DB	0aH
	DB	0cH
	DB	0eH
	DB	010H
	DB	012H
	DB	014H
	DB	014H
	DB	018H
	DB	018H
	DB	01eH
	DB	01eH
_lfo_am_table DB 00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	01aH
	DB	01aH
	DB	01aH
	DB	019H
	DB	019H
	DB	019H
	DB	019H
	DB	018H
	DB	018H
	DB	018H
	DB	018H
	DB	017H
	DB	017H
	DB	017H
	DB	017H
	DB	016H
	DB	016H
	DB	016H
	DB	016H
	DB	015H
	DB	015H
	DB	015H
	DB	015H
	DB	014H
	DB	014H
	DB	014H
	DB	014H
	DB	013H
	DB	013H
	DB	013H
	DB	013H
	DB	012H
	DB	012H
	DB	012H
	DB	012H
	DB	011H
	DB	011H
	DB	011H
	DB	011H
	DB	010H
	DB	010H
	DB	010H
	DB	010H
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0fH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0eH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0dH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0cH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0bH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	0aH
	DB	09H
	DB	09H
	DB	09H
	DB	09H
	DB	08H
	DB	08H
	DB	08H
	DB	08H
	DB	07H
	DB	07H
	DB	07H
	DB	07H
	DB	06H
	DB	06H
	DB	06H
	DB	06H
	DB	05H
	DB	05H
	DB	05H
	DB	05H
	DB	04H
	DB	04H
	DB	04H
	DB	04H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	ORG $+6
_lfo_pm_table DB 00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	02H
	DB	01H
	DB	00H
	DB	0ffH
	DB	0feH
	DB	0ffH
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	03H
	DB	01H
	DB	00H
	DB	0ffH
	DB	0fdH
	DB	0ffH
	DB	00H
	DB	01H
	DB	02H
	DB	01H
	DB	00H
	DB	0ffH
	DB	0feH
	DB	0ffH
	DB	00H
	DB	01H
	DB	04H
	DB	02H
	DB	00H
	DB	0feH
	DB	0fcH
	DB	0feH
	DB	00H
	DB	02H
	DB	02H
	DB	01H
	DB	00H
	DB	0ffH
	DB	0feH
	DB	0ffH
	DB	00H
	DB	01H
	DB	05H
	DB	02H
	DB	00H
	DB	0feH
	DB	0fbH
	DB	0feH
	DB	00H
	DB	02H
	DB	03H
	DB	01H
	DB	00H
	DB	0ffH
	DB	0fdH
	DB	0ffH
	DB	00H
	DB	01H
	DB	06H
	DB	03H
	DB	00H
	DB	0fdH
	DB	0faH
	DB	0fdH
	DB	00H
	DB	03H
	DB	03H
	DB	01H
	DB	00H
	DB	0ffH
	DB	0fdH
	DB	0ffH
	DB	00H
	DB	01H
	DB	07H
	DB	03H
	DB	00H
	DB	0fdH
	DB	0f9H
	DB	0fdH
	DB	00H
	DB	03H
CONST	ENDS
PUBLIC	?CALC_FCSLOT@@YIXPAUOPL_CH@@PAUOPL_SLOT@@@Z	; CALC_FCSLOT
; Function compile flags: /Ogty
; File F:\zdoom\zdoom-2.0\src\oplsynth\fmopl.cpp
_TEXT	SEGMENT
?CALC_FCSLOT@@YIXPAUOPL_CH@@PAUOPL_SLOT@@@Z PROC NEAR	; CALC_FCSLOT
; _CH$ = ecx
; _SLOT$ = edx

; 1052 : 	int ksr;
; 1053 : 
; 1054 : 	/* (frequency) phase increment counter */
; 1055 : 	SLOT->Incr = CH->fc * SLOT->mul;

	xor	eax, eax
	mov	al, BYTE PTR [edx+15]
	imul	eax, DWORD PTR [ecx+172]
	mov	DWORD PTR [edx+20], eax

; 1056 : 	ksr = CH->kcode >> SLOT->KSR;

	xor	eax, eax
	mov	al, BYTE PTR [ecx+180]
	mov	cl, BYTE PTR [edx+12]
	shr	eax, cl

; 1057 : 
; 1058 : 	if( SLOT->ksr != ksr )

	xor	ecx, ecx
	mov	cl, BYTE PTR [edx+14]
	cmp	ecx, eax
	je	SHORT $L1857

; 1059 : 	{
; 1060 : 		SLOT->ksr = ksr;
; 1061 : 
; 1062 : 		/* calculate envelope generator rates */
; 1063 : 		if ((SLOT->ar + SLOT->ksr) < 16+62)

	mov	ecx, DWORD PTR [edx]
	mov	BYTE PTR [edx+14], al
	and	eax, 255				; 000000ffH
	push	esi
	lea	esi, DWORD PTR [eax+ecx]
	cmp	esi, 78					; 0000004eH
	jae	SHORT $L1858

; 1064 : 		{
; 1065 : 			SLOT->eg_sh_ar  = eg_rate_shift [SLOT->ar + SLOT->ksr ];

	mov	cl, BYTE PTR _eg_rate_shift[esi]
	mov	BYTE PTR [edx+60], cl

; 1066 : 			SLOT->eg_sel_ar = eg_rate_select[SLOT->ar + SLOT->ksr ];

	mov	cl, BYTE PTR _eg_rate_select[esi]
	mov	BYTE PTR [edx+61], cl

; 1067 : 		}
; 1068 : 		else

	jmp	SHORT $L1859
$L1858:

; 1069 : 		{
; 1070 : 			SLOT->eg_sh_ar  = 0;

	mov	BYTE PTR [edx+60], 0

; 1071 : 			SLOT->eg_sel_ar = 13*RATE_STEPS;

	mov	BYTE PTR [edx+61], 104			; 00000068H
$L1859:

; 1072 : 		}
; 1073 : 		SLOT->eg_sh_dr  = eg_rate_shift [SLOT->dr + SLOT->ksr ];

	mov	ecx, DWORD PTR [edx+4]
	lea	esi, DWORD PTR [ecx+eax]
	mov	cl, BYTE PTR _eg_rate_shift[esi]
	mov	BYTE PTR [edx+62], cl

; 1074 : 		SLOT->eg_sel_dr = eg_rate_select[SLOT->dr + SLOT->ksr ];

	mov	cl, BYTE PTR _eg_rate_select[esi]
	mov	BYTE PTR [edx+63], cl

; 1075 : 		SLOT->eg_sh_rr  = eg_rate_shift [SLOT->rr + SLOT->ksr ];

	mov	ecx, DWORD PTR [edx+8]
	add	eax, ecx
	pop	esi
	mov	cl, BYTE PTR _eg_rate_shift[eax]
	mov	BYTE PTR [edx+64], cl

; 1076 : 		SLOT->eg_sel_rr = eg_rate_select[SLOT->rr + SLOT->ksr ];

	mov	al, BYTE PTR _eg_rate_select[eax]
	mov	BYTE PTR [edx+65], al
$L1857:

; 1077 : 	}
; 1078 : }

	ret	0
?CALC_FCSLOT@@YIXPAUOPL_CH@@PAUOPL_SLOT@@@Z ENDP	; CALC_FCSLOT
_TEXT	ENDS
PUBLIC	?set_mul@@YIXPAUfm_opl_f@@HH@Z			; set_mul
; Function compile flags: /Ogty
_TEXT	SEGMENT
_v$ = 8
?set_mul@@YIXPAUfm_opl_f@@HH@Z PROC NEAR		; set_mul
; _OPL$ = ecx
; _slot$ = edx

; 1082 : {

	push	esi
	mov	esi, edx

; 1083 : 	OPL_CH   *CH   = &OPL->P_CH[slot/2];

	mov	eax, esi

; 1084 : 	OPL_SLOT *SLOT = &CH->SLOT[slot&1];

	and	esi, 1
	cdq
	sub	eax, edx
	push	edi
	sar	eax, 1
	lea	edx, DWORD PTR [eax+eax*2]
	shl	edx, 3
	sub	edx, eax
	lea	eax, DWORD PTR [esi*8]
	sub	eax, esi
	lea	edi, DWORD PTR [ecx+edx*8]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	edx, DWORD PTR [edi+eax*4]

; 1085 : 
; 1086 : 	SLOT->mul     = mul_tab[v&0x0f];

	mov	eax, DWORD PTR _v$[esp+4]
	mov	ecx, eax
	and	ecx, 15					; 0000000fH
	mov	cl, BYTE PTR _mul_tab[ecx]
	mov	BYTE PTR [edx+15], cl

; 1087 : 	SLOT->KSR     = (v&0x10) ? 0 : 2;

	mov	ecx, eax
	shr	ecx, 3
	not	cl
	and	cl, 2
	mov	BYTE PTR [edx+12], cl

; 1088 : 	SLOT->eg_type = (v&0x20);

	mov	cl, al
	and	cl, 32					; 00000020H
	mov	BYTE PTR [edx+41], cl

; 1089 : 	SLOT->vib     = (v&0x40);

	mov	cl, al

; 1090 : 	SLOT->AMmask  = (v&0x80) ? ~0 : 0;

	and	al, -128				; ffffff80H
	and	cl, 64					; 00000040H
	neg	al
	mov	BYTE PTR [edx+76], cl

; 1091 : 	CALC_FCSLOT(CH,SLOT);

	mov	ecx, edi
	sbb	eax, eax
	mov	DWORD PTR [edx+72], eax
	call	?CALC_FCSLOT@@YIXPAUOPL_CH@@PAUOPL_SLOT@@@Z ; CALC_FCSLOT
	pop	edi
	pop	esi

; 1092 : }

	ret	4
?set_mul@@YIXPAUfm_opl_f@@HH@Z ENDP			; set_mul
_TEXT	ENDS
PUBLIC	?set_ksl_tl@@YIXPAUfm_opl_f@@HH@Z		; set_ksl_tl
; Function compile flags: /Ogty
_TEXT	SEGMENT
_v$ = 8
?set_ksl_tl@@YIXPAUfm_opl_f@@HH@Z PROC NEAR		; set_ksl_tl
; _OPL$ = ecx
; _slot$ = edx

; 1096 : {

	push	esi
	mov	esi, edx

; 1097 : 	OPL_CH   *CH   = &OPL->P_CH[slot/2];

	mov	eax, esi

; 1098 : 	OPL_SLOT *SLOT = &CH->SLOT[slot&1];

	and	esi, 1
	cdq
	sub	eax, edx
	push	edi
	sar	eax, 1
	lea	edx, DWORD PTR [eax+eax*2]
	shl	edx, 3
	sub	edx, eax
	lea	eax, DWORD PTR [esi*8]
	sub	eax, esi

; 1099 : 	int ksl = v>>6; /* 0 / 1.5 / 3.0 / 6.0 dB/OCT */

	mov	esi, DWORD PTR _v$[esp+4]
	lea	edi, DWORD PTR [ecx+edx*8]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	edx, DWORD PTR [edi+eax*4]
	mov	eax, esi
	sar	eax, 6

; 1100 : 
; 1101 : 	SLOT->ksl = ksl ? 3-ksl : 31;

	je	SHORT $L2190
	mov	ecx, 3
	sub	ecx, eax
	jmp	SHORT $L2191
$L2190:
	mov	ecx, 31					; 0000001fH
$L2191:

; 1102 : 	SLOT->TL  = (v&0x3f)<<(ENV_BITS-1-7); /* 7 bits TL (bit 6 = always 0) */

	and	esi, 63					; 0000003fH
	mov	BYTE PTR [edx+13], cl
	lea	eax, DWORD PTR [esi*4]
	mov	DWORD PTR [edx+44], eax

; 1103 : 
; 1104 : 	SLOT->TLL = SLOT->TL + (CH->ksl_base>>SLOT->ksl);

	mov	esi, DWORD PTR [edi+176]
	shr	esi, cl
	pop	edi
	add	esi, eax
	mov	DWORD PTR [edx+48], esi
	pop	esi

; 1105 : }

	ret	4
?set_ksl_tl@@YIXPAUfm_opl_f@@HH@Z ENDP			; set_ksl_tl
_TEXT	ENDS
PUBLIC	?set_sl_rr@@YIXPAUfm_opl_f@@HH@Z		; set_sl_rr
; Function compile flags: /Ogty
_TEXT	SEGMENT
_v$ = 8
?set_sl_rr@@YIXPAUfm_opl_f@@HH@Z PROC NEAR		; set_sl_rr
; _OPL$ = ecx
; _slot$ = edx

; 1133 : {

	push	esi
	mov	esi, edx

; 1134 : 	OPL_CH   *CH   = &OPL->P_CH[slot/2];

	mov	eax, esi

; 1135 : 	OPL_SLOT *SLOT = &CH->SLOT[slot&1];

	and	esi, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	lea	edx, DWORD PTR [eax+eax*2]
	shl	edx, 3
	sub	edx, eax
	lea	eax, DWORD PTR [esi*8]
	sub	eax, esi
	pop	esi
	lea	eax, DWORD PTR [eax+eax*2]

; 1141 : 	SLOT->eg_sel_rr = eg_rate_select[SLOT->rr + SLOT->ksr ];

	lea	ecx, DWORD PTR [ecx+eax*4]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	ecx, DWORD PTR _v$[esp-4]
	mov	edx, ecx
	sar	edx, 4
	and	ecx, 15					; 0000000fH
	mov	edx, DWORD PTR _sl_tab[edx*4]
	mov	DWORD PTR [eax+56], edx
	je	SHORT $L2193

; 1136 : 
; 1137 : 	SLOT->sl  = sl_tab[ v>>4 ];
; 1138 : 
; 1139 : 	SLOT->rr  = (v&0x0f)? 16 + ((v&0x0f)<<2) : 0;

	lea	ecx, DWORD PTR [ecx*4+16]
	jmp	SHORT $L2194
$L2193:
	xor	ecx, ecx
$L2194:

; 1140 : 	SLOT->eg_sh_rr  = eg_rate_shift [SLOT->rr + SLOT->ksr ];

	xor	edx, edx
	mov	DWORD PTR [eax+8], ecx
	mov	dl, BYTE PTR [eax+14]
	add	ecx, edx
	mov	dl, BYTE PTR _eg_rate_shift[ecx]
	mov	BYTE PTR [eax+64], dl

; 1141 : 	SLOT->eg_sel_rr = eg_rate_select[SLOT->rr + SLOT->ksr ];

	mov	cl, BYTE PTR _eg_rate_select[ecx]
	mov	BYTE PTR [eax+65], cl

; 1142 : }

	ret	4
?set_sl_rr@@YIXPAUfm_opl_f@@HH@Z ENDP			; set_sl_rr
_TEXT	ENDS
PUBLIC	__real@3f8c71c71c71c71c
PUBLIC	__real@0000000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40b0000000000000
PUBLIC	__real@4110000000000000
PUBLIC	__real@40d0000000000000
PUBLIC	__real@40f0000000000000
PUBLIC	?YM3812Init@@YIHHHH@Z				; YM3812Init
EXTRN	__ftol:NEAR
EXTRN	__fltused:NEAR
EXTRN	_malloc:NEAR
_BSS	SEGMENT
_OPL_YM3812 DD	02H DUP (?)
_BSS	ENDS
;	COMDAT __real@3f8c71c71c71c71c
CONST	SEGMENT
__real@3f8c71c71c71c71c DQ 03f8c71c71c71c71cr	; 0.0138889
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@40b0000000000000
CONST	SEGMENT
__real@40b0000000000000 DQ 040b0000000000000r	; 4096
CONST	ENDS
;	COMDAT __real@4110000000000000
CONST	SEGMENT
__real@4110000000000000 DQ 04110000000000000r	; 262144
CONST	ENDS
;	COMDAT __real@40d0000000000000
CONST	SEGMENT
__real@40d0000000000000 DQ 040d0000000000000r	; 16384
CONST	ENDS
;	COMDAT __real@40f0000000000000
CONST	SEGMENT
__real@40f0000000000000 DQ 040f0000000000000r	; 65536
; Function compile flags: /Ogty
CONST	ENDS
_TEXT	SEGMENT
_clock$ = -12
_rate$ = 8
_i$ = -4
_i$2223 = -8
?YM3812Init@@YIHHHH@Z PROC NEAR				; YM3812Init
; _num$ = ecx
; _clock$ = edx

; 1535 : {

	sub	esp, 12					; 0000000cH

; 1536 : 	int i;
; 1537 : 
; 1538 : 	if (YM3812NumChips)

	mov	eax, DWORD PTR _YM3812NumChips
	push	ebx
	push	ebp
	push	esi
	test	eax, eax
	push	edi
	mov	DWORD PTR _clock$[esp+28], edx
	je	SHORT $L2046
	pop	edi
	pop	esi
	pop	ebp

; 1539 : 		return -1;	/* duplicate init. */

	or	eax, -1
	pop	ebx

; 1556 : }

	add	esp, 12					; 0000000cH
	ret	4
$L2046:

; 1540 : 
; 1541 : 	YM3812NumChips = num;
; 1542 : 
; 1543 : 	for (i = 0;i < YM3812NumChips; i++)

	xor	edi, edi
	mov	DWORD PTR _YM3812NumChips, ecx
	test	ecx, ecx
	mov	DWORD PTR _i$[esp+28], edi
	jle	$L2049
	mov	ebx, DWORD PTR _rate$[esp+24]
$L2047:

; 1544 : 	{
; 1545 : 		/* emulator create */
; 1546 : 		OPL_YM3812[i] = OPLCreate(OPL_TYPE_YM3812,clock,rate);

	mov	eax, DWORD PTR _num_lock
	inc	eax
	cmp	eax, 1
	mov	DWORD PTR _num_lock, eax
	jg	SHORT $L2231
	mov	DWORD PTR _cur_chip, 0
	call	?init_tables@@YIHXZ			; init_tables
	test	eax, eax
	jne	SHORT $L2231
	mov	eax, DWORD PTR _num_lock
	dec	eax
	xor	esi, esi
	mov	DWORD PTR _num_lock, eax
	jmp	$L2227
$L2231:
	push	5864					; 000016e8H
	call	_malloc
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	$L2227
$L2232:
	mov	ecx, 1466				; 000005baH
	xor	eax, eax
	mov	edi, esi
	rep stosd
	mov	eax, DWORD PTR _clock$[esp+28]
	mov	BYTE PTR [esi+5828], 1
	test	ebx, ebx
	mov	DWORD PTR [esi+5836], eax
	mov	DWORD PTR [esi+5840], ebx
	je	SHORT $L2220
	fild	DWORD PTR _clock$[esp+28]
	fmul	QWORD PTR __real@3f8c71c71c71c71c
	fidiv	DWORD PTR _rate$[esp+24]
	jmp	SHORT $L2221
$L2220:
	fld	QWORD PTR __real@0000000000000000
$L2221:
	fstp	QWORD PTR [esi+5848]
	fild	DWORD PTR _clock$[esp+28]
	xor	edi, edi
	lea	ebp, DWORD PTR [esi+1672]
	mov	DWORD PTR _i$2223[esp+28], edi
	fmul	QWORD PTR __real@3f8c71c71c71c71c
	fdivr	QWORD PTR __real@3ff0000000000000
	fstp	QWORD PTR [esi+5856]
$L2224:
	fild	DWORD PTR _i$2223[esp+28]
	fmul	QWORD PTR [esi+5848]
	fmul	QWORD PTR __real@40b0000000000000
	call	__ftol
	mov	DWORD PTR [ebp], eax
	inc	edi
	add	ebp, 4
	cmp	edi, 1024				; 00000400H
	mov	DWORD PTR _i$2223[esp+28], edi
	jl	SHORT $L2224
	fld	QWORD PTR [esi+5848]
	fmul	QWORD PTR __real@4110000000000000
	call	__ftol
	fld	QWORD PTR [esi+5848]
	fmul	QWORD PTR __real@40d0000000000000
	mov	DWORD PTR [esi+5776], eax
	call	__ftol
	fld	QWORD PTR [esi+5848]
	fmul	QWORD PTR __real@40f0000000000000
	mov	DWORD PTR [esi+5784], eax
	call	__ftol
	mov	ecx, esi
	mov	DWORD PTR [esi+1664], eax
	mov	DWORD PTR [esi+1668], 65536		; 00010000H
	call	?OPLResetChip@@YIXPAUfm_opl_f@@@Z	; OPLResetChip
	mov	edi, DWORD PTR _i$[esp+28]
$L2227:

; 1547 : 		if(OPL_YM3812[i] == NULL)

	test	esi, esi
	mov	DWORD PTR _OPL_YM3812[edi*4], esi
	je	SHORT $L2237
	mov	eax, DWORD PTR _YM3812NumChips
	inc	edi
	cmp	edi, eax
	mov	DWORD PTR _i$[esp+28], edi
	jl	$L2047
$L2049:
	pop	edi
	pop	esi
	pop	ebp

; 1552 : 		}
; 1553 : 	}
; 1554 : 
; 1555 : 	return 0;

	xor	eax, eax
	pop	ebx

; 1556 : }

	add	esp, 12					; 0000000cH
	ret	4
$L2237:
	pop	edi
	pop	esi
	pop	ebp

; 1548 : 		{
; 1549 : 			/* it's really bad - we run out of memeory */
; 1550 : 			YM3812NumChips = 0;

	mov	DWORD PTR _YM3812NumChips, 0

; 1551 : 			return -1;

	or	eax, -1
	pop	ebx

; 1556 : }

	add	esp, 12					; 0000000cH
	ret	4
?YM3812Init@@YIHHHH@Z ENDP				; YM3812Init
_TEXT	ENDS
PUBLIC	__real@4000000000000000
PUBLIC	__real@3f70000000000000
PUBLIC	__real@3f6921fb54442d18
PUBLIC	__real@4020000000000000
PUBLIC	__real@bff0000000000000
PUBLIC	__real@4040000000000000
EXTRN	_floor:NEAR
EXTRN	__CIpow:NEAR
_BSS	SEGMENT
_tl_tab	DD	01800H DUP (?)
_sin_tab DD	01000H DUP (?)
_BSS	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@3f70000000000000
CONST	SEGMENT
__real@3f70000000000000 DQ 03f70000000000000r	; 0.00390625
CONST	ENDS
;	COMDAT __real@3f6921fb54442d18
CONST	SEGMENT
__real@3f6921fb54442d18 DQ 03f6921fb54442d18r	; 0.00306796
CONST	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
;	COMDAT __real@4020000000000000
CONST	SEGMENT
__real@4020000000000000 DQ 04020000000000000r	; 8
CONST	ENDS
;	COMDAT __real@4040000000000000
CONST	SEGMENT
__real@4040000000000000 DQ 04040000000000000r	; 32
; Function compile flags: /Ogty
CONST	ENDS
_TEXT	SEGMENT
?init_tables@@YIHXZ PROC NEAR				; init_tables

; 851  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 8
	push	esi
	push	edi

; 852  : 	signed int i,x;
; 853  : 	signed int n;
; 854  : 	double o,m;
; 855  : 
; 856  : 
; 857  : 	for (x=0; x<TL_RES_LEN; x++)

	xor	eax, eax
	mov	esi, OFFSET FLAT:_tl_tab
$L1804:

; 858  : 	{
; 859  : 		m = (1<<16) / pow(2.0, (x+1) * (ENV_STEP/4.0) / 8.0);

	fld	QWORD PTR __real@4000000000000000

; 938  : 
; 939  : 		/*logerror("FMOPL.C: sin1[%4i]= %4i (tl_tab value=%5i)\n", i, sin_tab[1*SIN_LEN+i], tl_tab[sin_tab[1*SIN_LEN+i]] );
; 940  : 		logerror("FMOPL.C: sin2[%4i]= %4i (tl_tab value=%5i)\n", i, sin_tab[2*SIN_LEN+i], tl_tab[sin_tab[2*SIN_LEN+i]] );
; 941  : 		logerror("FMOPL.C: sin3[%4i]= %4i (tl_tab value=%5i)\n", i, sin_tab[3*SIN_LEN+i], tl_tab[sin_tab[3*SIN_LEN+i]] );*/
; 942  : 	}
; 943  : 	/*logerror("FMOPL.C: ENV_QUIET= %08x (dec*8=%i)\n", ENV_QUIET, ENV_QUIET*8 );*/
; 944  : 
; 945  : 
; 946  : #ifdef SAVE_SAMPLE
; 947  : 	sample[0]=fopen("sampsum.pcm","wb");
; 948  : #endif
; 949  : 
; 950  : 	return 1;

	lea	edi, DWORD PTR [eax+1]
	mov	DWORD PTR -4+[esp+16], edi
	fild	DWORD PTR -4+[esp+16]
	fmul	QWORD PTR __real@3f70000000000000
	call	__CIpow
	fdivr	QWORD PTR __real@40f0000000000000
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	call	__ftol
	sar	eax, 4
	inc	eax
	mov	ecx, 1
	and	al, -2					; fffffffeH
	mov	DWORD PTR [esi], eax
	neg	eax
	mov	DWORD PTR [esi+4], eax
	lea	eax, DWORD PTR [esi+2052]
$L1808:
	mov	edx, DWORD PTR [esi]
	add	eax, 2048				; 00000800H
	sar	edx, cl
	mov	DWORD PTR [eax-2052], edx
	mov	edx, DWORD PTR [esi]
	neg	edx
	sar	edx, cl
	inc	ecx
	cmp	ecx, 12					; 0000000cH
	mov	DWORD PTR [eax-2048], edx
	jl	SHORT $L1808
	add	esi, 8
	mov	eax, edi
	cmp	esi, OFFSET FLAT:_tl_tab+2048
	jl	SHORT $L1804
	fldln2
	mov	esi, 1
	mov	edi, OFFSET FLAT:_sin_tab
	mov	DWORD PTR -4+[esp+16], esi
	fld	QWORD PTR __real@4000000000000000
	fyl2x
$L1811:
	fild	DWORD PTR -4+[esp+16]
	fmul	QWORD PTR __real@3f6921fb54442d18
	fsin
	fcom	QWORD PTR __real@0000000000000000
	fnstsw	ax
	and	eax, 16640				; 00004100H
	jne	SHORT $L1814

; 860  : 		m = floor(m);
; 861  : 
; 862  : 		/* we never reach (1<<16) here due to the (x+1) */
; 863  : 		/* result fits within 16 bits at maximum */
; 864  : 
; 865  : 		n = (int)m;		/* 16 bits here */
; 866  : 		n >>= 4;		/* 12 bits here */
; 867  : 		n = (n+1)>>1;	/* round to nearest */
; 868  : 						/* 11 bits here (rounded) */
; 869  : 		n <<= 1;		/* 12 bits here (as in real chip) */
; 870  : 		tl_tab[ x*2 + 0 ] = n;
; 871  : 		tl_tab[ x*2 + 1 ] = -tl_tab[ x*2 + 0 ];
; 872  : 
; 873  : 		for (i=1; i<12; i++)
; 874  : 		{
; 875  : 			tl_tab[ x*2+0 + i*2*TL_RES_LEN ] =  tl_tab[ x*2+0 ]>>i;
; 876  : 			tl_tab[ x*2+1 + i*2*TL_RES_LEN ] = -tl_tab[ x*2+0 ]>>i;
; 877  : 		}
; 878  : 	#if 0
; 879  : 			logerror("tl %04i", x*2);
; 880  : 			for (i=0; i<12; i++)
; 881  : 				logerror(", [%02i] %5i", i*2, tl_tab[ x*2 /*+1*/ + i*2*TL_RES_LEN ] );
; 882  : 			logerror("\n");
; 883  : 	#endif
; 884  : 	}
; 885  : 	/*logerror("FMOPL.C: TL_TAB_LEN = %i elements (%i bytes)\n",TL_TAB_LEN, (int)sizeof(tl_tab));*/
; 886  : 
; 887  : 
; 888  : 	for (i=0; i<SIN_LEN; i++)
; 889  : 	{
; 890  : 		/* non-standard sinus */
; 891  : 		m = sin( ((i*2)+1) * PI / SIN_LEN ); /* checked against the real chip */
; 892  : 
; 893  : 		/* we never reach zero here due to ((i*2)+1) */
; 894  : 
; 895  : 		if (m>0.0)
; 896  : 			o = 8*log(1.0/m)/log(2.0);	/* convert to 'decibels' */

	fld	QWORD PTR __real@3ff0000000000000

; 897  : 		else

	jmp	SHORT $L2282
$L1814:

; 898  : 			o = 8*log(-1.0/m)/log(2.0);	/* convert to 'decibels' */

	fld	QWORD PTR __real@bff0000000000000
$L2282:
	fdiv	ST(0), ST(1)
	fldln2
	fxch	ST(1)
	fyl2x
	fmul	QWORD PTR __real@4020000000000000
	fdiv	ST(0), ST(2)

; 899  : 
; 900  : 		o = o / (ENV_STEP/4);

	fmul	QWORD PTR __real@4040000000000000

; 901  : 
; 902  : 		n = (int)(2.0*o);

	fadd	ST(0), ST(0)
	call	__ftol
	mov	ecx, eax

; 903  : 		if (n&1)						/* round to nearest */

	test	cl, 1
	je	SHORT $L1817

; 904  : 			n = (n>>1)+1;

	sar	ecx, 1
	inc	ecx

; 905  : 		else

	jmp	SHORT $L1818
$L1817:

; 906  : 			n = n>>1;

	sar	ecx, 1
$L1818:

; 907  : 
; 908  : 		sin_tab[ i ] = n*2 + (m>=0.0? 0: 1 );

	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	and	eax, 256				; 00000100H
	jne	SHORT $L2259
	xor	eax, eax
	jmp	SHORT $L2260
$L2259:
	mov	eax, 1
$L2260:
	lea	eax, DWORD PTR [eax+ecx*2]
	add	esi, 2
	mov	DWORD PTR [edi], eax
	add	edi, 4
	cmp	esi, 2049				; 00000801H
	mov	DWORD PTR -4+[esp+16], esi
	jl	$L1811
	fstp	ST(0)

; 909  : 
; 910  : 		/*logerror("FMOPL.C: sin [%4i (hex=%03x)]= %4i (tl_tab value=%5i)\n", i, i, sin_tab[i], tl_tab[sin_tab[i]] );*/
; 911  : 	}
; 912  : 
; 913  : 	for (i=0; i<SIN_LEN; i++)

	xor	eax, eax
	mov	ecx, 6144				; 00001800H
$L1819:

; 914  : 	{
; 915  : 		/* waveform 1:  __      __     */
; 916  : 		/*             /  \____/  \____*/
; 917  : 		/* output only first half of the sinus waveform (positive one) */
; 918  : 
; 919  : 		if (i & (1<<(SIN_BITS-1)) )

	test	ah, 2
	je	SHORT $L1822

; 920  : 			sin_tab[1*SIN_LEN+i] = TL_TAB_LEN;

	mov	DWORD PTR _sin_tab[eax*4+4096], ecx

; 921  : 		else

	jmp	SHORT $L1823
$L1822:

; 922  : 			sin_tab[1*SIN_LEN+i] = sin_tab[i];

	mov	edx, DWORD PTR _sin_tab[eax*4]
	mov	DWORD PTR _sin_tab[eax*4+4096], edx
$L1823:

; 923  : 
; 924  : 		/* waveform 2:  __  __  __  __ */
; 925  : 		/*             /  \/  \/  \/  \*/
; 926  : 		/* abs(sin) */
; 927  : 
; 928  : 		sin_tab[2*SIN_LEN+i] = sin_tab[i & (SIN_MASK>>1) ];

	mov	edx, eax
	and	edx, 511				; 000001ffH

; 929  : 
; 930  : 		/* waveform 3:  _   _   _   _  */
; 931  : 		/*             / |_/ |_/ |_/ |_*/
; 932  : 		/* abs(output only first quarter of the sinus waveform) */
; 933  : 
; 934  : 		if (i & (1<<(SIN_BITS-2)) )

	test	ah, 1
	mov	edx, DWORD PTR _sin_tab[edx*4]
	mov	DWORD PTR _sin_tab[eax*4+8192], edx
	je	SHORT $L1824

; 935  : 			sin_tab[3*SIN_LEN+i] = TL_TAB_LEN;

	mov	DWORD PTR _sin_tab[eax*4+12288], ecx

; 936  : 		else

	jmp	SHORT $L1820
$L1824:

; 937  : 			sin_tab[3*SIN_LEN+i] = sin_tab[i & (SIN_MASK>>2)];

	mov	edx, eax
	and	edx, 255				; 000000ffH
	mov	edx, DWORD PTR _sin_tab[edx*4]
	mov	DWORD PTR _sin_tab[eax*4+12288], edx
$L1820:
	inc	eax
	cmp	eax, 1024				; 00000400H
	jl	SHORT $L1819

; 951  : }

	pop	edi
	mov	eax, 1
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?init_tables@@YIHXZ ENDP				; init_tables
; Function compile flags: /Ogty
?OPLResetChip@@YIXPAUfm_opl_f@@@Z PROC NEAR		; OPLResetChip
; _OPL$ = ecx

; 1370 : {

	push	ebx
	push	esi
	mov	esi, ecx

; 1371 : 	int c,s;
; 1372 : 	int i;
; 1373 : 
; 1374 : 	OPL->eg_timer = 0;

	xor	ebx, ebx
	push	edi

; 1375 : 	OPL->eg_cnt   = 0;
; 1376 : 
; 1377 : 	OPL->mode   = 0;	/* normal mode */
; 1378 : 	OPL_STATUS_RESET(OPL,0x7f);

	mov	dl, BYTE PTR [esi+5830]
	mov	DWORD PTR [esi+1660], ebx
	and	dl, 128					; 00000080H
	mov	DWORD PTR [esi+1656], ebx
	mov	al, dl
	mov	BYTE PTR [esi+5832], bl
	test	al, al
	mov	BYTE PTR [esi+5830], dl
	jns	SHORT $L2289
	test	BYTE PTR [esi+5831], al
	jne	SHORT $L2289
	and	al, 127					; 0000007fH
	mov	BYTE PTR [esi+5830], al
	mov	eax, DWORD PTR [esi+5812]
	cmp	eax, ebx
	je	SHORT $L2289
	mov	ecx, DWORD PTR [esi+5816]
	xor	edx, edx
	call	eax
$L2289:

; 1379 : 
; 1380 : 	/* reset with register write */
; 1381 : 	OPLWriteReg(OPL,0x01,0); /* wavesel disable */

	push	ebx
	mov	edx, 1
	mov	ecx, esi
	call	?OPLWriteReg@@YIXPAUfm_opl_f@@HH@Z	; OPLWriteReg

; 1382 : 	OPLWriteReg(OPL,0x02,0); /* Timer1 */

	mov	edx, 2
	mov	ecx, esi
	push	ebx
	call	?OPLWriteReg@@YIXPAUfm_opl_f@@HH@Z	; OPLWriteReg

; 1383 : 	OPLWriteReg(OPL,0x03,0); /* Timer2 */

	mov	edx, 3
	mov	ecx, esi
	push	ebx
	call	?OPLWriteReg@@YIXPAUfm_opl_f@@HH@Z	; OPLWriteReg

; 1384 : 	OPLWriteReg(OPL,0x04,0); /* IRQ mask clear */

	mov	edx, 4
	mov	ecx, esi
	push	ebx
	call	?OPLWriteReg@@YIXPAUfm_opl_f@@HH@Z	; OPLWriteReg

; 1385 : 	for(i = 0xff ; i >= 0x20 ; i-- ) OPLWriteReg(OPL,i,0);

	mov	edi, 255				; 000000ffH
$L1966:
	push	ebx
	mov	edx, edi
	mov	ecx, esi
	call	?OPLWriteReg@@YIXPAUfm_opl_f@@HH@Z	; OPLWriteReg
	dec	edi
	cmp	edi, 32					; 00000020H
	jge	SHORT $L1966

; 1386 : 
; 1387 : 	/* reset operator parameters */
; 1388 : 	for( c = 0 ; c < 9 ; c++ )

	lea	edx, DWORD PTR [esi+42]
	mov	edi, 9
	mov	esi, 511				; 000001ffH
$L1969:

; 1389 : 	{
; 1390 : 		OPL_CH *CH = &OPL->P_CH[c];

	mov	eax, edx
	mov	ecx, 2
$L1973:

; 1391 : 		for(s = 0 ; s < 2 ; s++ )
; 1392 : 		{
; 1393 : 			/* wave table */
; 1394 : 			CH->SLOT[s].wavetable = 0;

	mov	DWORD PTR [eax+38], ebx

; 1395 : 			CH->SLOT[s].state     = EG_OFF;

	mov	BYTE PTR [eax], bl

; 1396 : 			CH->SLOT[s].volume    = MAX_ATT_INDEX;

	mov	DWORD PTR [eax+10], esi
	add	eax, 84					; 00000054H
	dec	ecx
	jne	SHORT $L1973
	add	edx, 184				; 000000b8H
	dec	edi
	jne	SHORT $L1969
	pop	edi
	pop	esi
	pop	ebx

; 1397 : 		}
; 1398 : 	}
; 1399 : }

	ret	0
?OPLResetChip@@YIXPAUfm_opl_f@@@Z ENDP			; OPLResetChip
_TEXT	ENDS
_BSS	SEGMENT
_phase_modulation DD 01H DUP (?)
_output	DD	01H DUP (?)
; Function compile flags: /Ogty
_BSS	ENDS
_TEXT	SEGMENT
_v$ = 8
_st1$1915 = -10
_st2$1916 = -9
_interval$1918 = -8
_interval$1922 = -8
?OPLWriteReg@@YIXPAUfm_opl_f@@HH@Z PROC NEAR		; OPLWriteReg
; _OPL$ = ecx
; _r$ = edx

; 1147 : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 12					; 0000000cH
	push	ebx

; 1148 : 	OPL_CH *CH;
; 1149 : 	int slot;
; 1150 : 	int block_fnum;
; 1151 : 
; 1152 : 
; 1153 : 	/* adjust bus to 8 bits */
; 1154 : 	r &= 0xff;
; 1155 : 	v &= 0xff;

	mov	ebx, DWORD PTR _v$[ebp]
	push	esi
	and	edx, 255				; 000000ffH
	push	edi

; 1156 : 
; 1157 : #ifdef LOG_CYM_FILE
; 1158 : 	if ((cymfile) && (r!=0) )
; 1159 : 	{
; 1160 : 		fputc( (unsigned char)r, cymfile );
; 1161 : 		fputc( (unsigned char)v, cymfile );
; 1162 : 	}
; 1163 : #endif
; 1164 : 
; 1165 : 
; 1166 : 	switch(r&0xe0)
; 1167 : 	{

	mov	edi, edx
	and	edi, 224				; 000000e0H
	and	ebx, 255				; 000000ffH
	cmp	edi, 224				; 000000e0H
	mov	esi, ecx
	ja	$L1948
	xor	eax, eax
	mov	al, BYTE PTR $L2403[edi]
	jmp	DWORD PTR $L2408[eax*4]
$L1903:

; 1168 : 	case 0x00:	/* 00-1f:control */
; 1169 : 		switch(r&0x1f)
; 1170 : 		{

	and	edx, 31					; 0000001fH
	lea	eax, DWORD PTR [edx-1]
	cmp	eax, 3
	ja	$L1948
	jmp	DWORD PTR $L2409[eax*4]
$L1908:

; 1171 : 		case 0x01:	/* waveform select enable */
; 1172 : 			if(OPL->type&OPL_TYPE_WAVESEL)

	test	BYTE PTR [esi+5828], 1
	je	$L1948

; 1173 : 			{
; 1174 : 				OPL->wavesel = v&0x20;

	and	bl, 32					; 00000020H
	mov	BYTE PTR [esi+5788], bl

; 1310 : 		}
; 1311 : 		break;
; 1312 : 	}
; 1313 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L1910:

; 1175 : 				/* do not change the waveform previously selected */
; 1176 : 			}
; 1177 : 			break;
; 1178 : 		case 0x02:	/* Timer 1 */
; 1179 : 			OPL->T[0] = (256-v)*4;

	mov	ecx, 256				; 00000100H
	sub	ecx, ebx
	shl	ecx, 2
	mov	DWORD PTR [esi+5792], ecx

; 1310 : 		}
; 1311 : 		break;
; 1312 : 	}
; 1313 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L1911:

; 1180 : 			break;
; 1181 : 		case 0x03:	/* Timer 2 */
; 1182 : 			OPL->T[1] = (256-v)*16;

	mov	edx, 256				; 00000100H
	sub	edx, ebx
	shl	edx, 4
	mov	DWORD PTR [esi+5796], edx

; 1310 : 		}
; 1311 : 		break;
; 1312 : 	}
; 1313 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L1912:

; 1183 : 			break;
; 1184 : 		case 0x04:	/* IRQ clear / mask and Timer enable */
; 1185 : 			if(v&0x80)

	test	bl, bl
	jns	SHORT $L1913

; 1186 : 			{	/* IRQ flag clear */
; 1187 : 				OPL_STATUS_RESET(OPL,0x7f);

	mov	dl, BYTE PTR [esi+5830]
	and	dl, 128					; 00000080H
	mov	al, dl
	mov	BYTE PTR [esi+5830], dl
	test	al, al
	jns	$L1948
	test	BYTE PTR [esi+5831], al
	jne	$L1948
	and	al, 127					; 0000007fH
	mov	BYTE PTR [esi+5830], al
	mov	eax, DWORD PTR [esi+5812]
	test	eax, eax
	je	$L1948
	mov	ecx, DWORD PTR [esi+5816]
	xor	edx, edx
	call	eax

; 1310 : 		}
; 1311 : 		break;
; 1312 : 	}
; 1313 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L1913:

; 1188 : 			}
; 1189 : 			else
; 1190 : 			{	/* set IRQ mask ,timer enable*/
; 1191 : 				UINT8 st1 = v&1;
; 1192 : 				UINT8 st2 = (v>>1)&1;
; 1193 : 				/* IRQRST,T1MSK,t2MSK,EOSMSK,BRMSK,x,ST2,ST1 */
; 1194 : 				OPL_STATUS_RESET(OPL,v&0x78);

	mov	al, bl
	mov	ecx, ebx
	and	al, 120					; 00000078H
	mov	dl, bl
	not	al
	and	BYTE PTR [esi+5830], al
	mov	al, BYTE PTR [esi+5830]
	sar	ecx, 1
	and	dl, 1
	and	cl, 1
	test	al, al
	mov	BYTE PTR _st1$1915[esp+24], dl
	mov	BYTE PTR _st2$1916[esp+24], cl
	jns	SHORT $L2316
	test	BYTE PTR [esi+5831], al
	jne	SHORT $L2316
	and	al, 127					; 0000007fH
	mov	BYTE PTR [esi+5830], al
	mov	eax, DWORD PTR [esi+5812]
	test	eax, eax
	je	SHORT $L2316
	mov	ecx, DWORD PTR [esi+5816]
	xor	edx, edx
	call	eax
	mov	dl, BYTE PTR _st1$1915[esp+24]
	mov	cl, BYTE PTR _st2$1916[esp+24]
$L2316:

; 1195 : 				OPL_STATUSMASK_SET(OPL,((~v)&0x78)|0x01);

	mov	al, BYTE PTR [esi+5830]
	not	bl
	and	bl, 120					; 00000078H
	or	bl, 1
	test	al, al
	mov	BYTE PTR [esi+5831], bl
	js	SHORT $L2335
	test	bl, al
	je	SHORT $L2335
	or	al, 128					; 00000080H
	mov	BYTE PTR [esi+5830], al
	mov	eax, DWORD PTR [esi+5812]
	test	eax, eax
	je	SHORT $L2335
	mov	ecx, DWORD PTR [esi+5816]
	mov	edx, 1
	call	eax
	mov	dl, BYTE PTR _st1$1915[esp+24]
	mov	cl, BYTE PTR _st2$1916[esp+24]
$L2335:
	mov	al, BYTE PTR [esi+5830]
	test	al, al
	jns	SHORT $L2340
	test	al, BYTE PTR [esi+5831]
	jne	SHORT $L2340
	and	al, 127					; 0000007fH
	mov	BYTE PTR [esi+5830], al
	mov	eax, DWORD PTR [esi+5812]
	test	eax, eax
	je	SHORT $L2340
	mov	ecx, DWORD PTR [esi+5816]
	xor	edx, edx
	call	eax
	mov	dl, BYTE PTR _st1$1915[esp+24]
	mov	cl, BYTE PTR _st2$1916[esp+24]
$L2340:

; 1196 : 				/* timer 2 */
; 1197 : 				if(OPL->st[1] != st2)

	cmp	BYTE PTR [esi+5801], cl
	je	SHORT $L1920

; 1198 : 				{
; 1199 : 					double interval = st2 ? (double)OPL->T[1]*OPL->TimerBase : 0.0;

	test	cl, cl
	je	SHORT $L2297
	fild	DWORD PTR [esi+5796]
	fmul	QWORD PTR [esi+5856]
	fstp	QWORD PTR _interval$1918[esp+24]
	jmp	SHORT $L2298
$L2297:
	mov	DWORD PTR _interval$1918[esp+24], 0
	mov	DWORD PTR _interval$1918[esp+28], 0
$L2298:

; 1200 : 					OPL->st[1] = st2;
; 1201 : 					if (OPL->TimerHandler) (OPL->TimerHandler)(OPL->TimerParam+1,interval);

	mov	eax, DWORD PTR [esi+5804]
	mov	BYTE PTR [esi+5801], cl
	test	eax, eax
	je	SHORT $L1920
	mov	ecx, DWORD PTR _interval$1918[esp+28]
	mov	edx, DWORD PTR _interval$1918[esp+24]
	push	ecx
	mov	ecx, DWORD PTR [esi+5808]
	push	edx
	inc	ecx
	call	eax
	mov	dl, BYTE PTR _st1$1915[esp+24]
$L1920:

; 1202 : 				}
; 1203 : 				/* timer 1 */
; 1204 : 				if(OPL->st[0] != st1)

	cmp	BYTE PTR [esi+5800], dl
	je	$L1948

; 1205 : 				{
; 1206 : 					double interval = st1 ? (double)OPL->T[0]*OPL->TimerBase : 0.0;

	test	dl, dl
	je	SHORT $L2299
	fild	DWORD PTR [esi+5792]
	fmul	QWORD PTR [esi+5856]
	fstp	QWORD PTR _interval$1922[esp+24]
	jmp	SHORT $L2300
$L2299:
	mov	DWORD PTR _interval$1922[esp+24], 0
	mov	DWORD PTR _interval$1922[esp+28], 0
$L2300:

; 1207 : 					OPL->st[0] = st1;
; 1208 : 					if (OPL->TimerHandler) (OPL->TimerHandler)(OPL->TimerParam+0,interval);

	mov	eax, DWORD PTR [esi+5804]
	mov	BYTE PTR [esi+5800], dl
	test	eax, eax
	je	$L1948
	mov	ecx, DWORD PTR _interval$1922[esp+28]
	mov	edx, DWORD PTR _interval$1922[esp+24]
	push	ecx
	mov	ecx, DWORD PTR [esi+5808]
	push	edx
	call	eax

; 1310 : 		}
; 1311 : 		break;
; 1312 : 	}
; 1313 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L1925:

; 1209 : 				}
; 1210 : 			}
; 1211 : 			break;
; 1212 : 		}
; 1213 : 		break;
; 1214 : 	case 0x20:	/* am ON, vib ON, ksr, eg_type, mul */
; 1215 : 		slot = slot_array[r&0x1f];

	and	edx, 31					; 0000001fH
	mov	edi, DWORD PTR _slot_array[edx*4]

; 1216 : 		if(slot < 0) return;

	test	edi, edi
	jl	$L1948

; 1217 : 		set_mul(OPL,slot,v);

	mov	eax, edi
	and	edi, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	lea	ecx, DWORD PTR [eax+eax*2]
	shl	ecx, 3
	sub	ecx, eax
	lea	eax, DWORD PTR [edi*8]
	sub	eax, edi
	lea	esi, DWORD PTR [esi+ecx*8]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, ebx
	and	eax, 15					; 0000000fH
	lea	edx, DWORD PTR [esi+edx*4]
	mov	cl, BYTE PTR _mul_tab[eax]
	mov	eax, ebx
	shr	eax, 3
	not	al
	and	al, 2
	mov	BYTE PTR [edx+15], cl
	mov	BYTE PTR [edx+12], al
	mov	cl, bl
	mov	al, bl
	and	bl, -128				; ffffff80H
	and	cl, 32					; 00000020H
	and	al, 64					; 00000040H
	neg	bl
	mov	BYTE PTR [edx+41], cl
	mov	ecx, esi
	sbb	ebx, ebx
	mov	BYTE PTR [edx+76], al
	mov	DWORD PTR [edx+72], ebx
	call	?CALC_FCSLOT@@YIXPAUOPL_CH@@PAUOPL_SLOT@@@Z ; CALC_FCSLOT

; 1310 : 		}
; 1311 : 		break;
; 1312 : 	}
; 1313 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L1927:

; 1218 : 		break;
; 1219 : 	case 0x40:
; 1220 : 		slot = slot_array[r&0x1f];

	and	edx, 31					; 0000001fH
	mov	ecx, DWORD PTR _slot_array[edx*4]

; 1221 : 		if(slot < 0) return;

	test	ecx, ecx
	jl	$L1948

; 1222 : 		set_ksl_tl(OPL,slot,v);

	mov	eax, ecx
	and	ecx, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	lea	edx, DWORD PTR [eax+eax*2]
	shl	edx, 3
	sub	edx, eax
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	edi, DWORD PTR [esi+edx*8]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	esi, DWORD PTR [edi+eax*4]
	mov	eax, ebx
	sar	eax, 6
	je	SHORT $L2351
	mov	ecx, 3
	sub	ecx, eax
	jmp	SHORT $L2352
$L2351:
	mov	ecx, 31					; 0000001fH
$L2352:
	and	ebx, 63					; 0000003fH
	mov	BYTE PTR [esi+13], cl
	lea	eax, DWORD PTR [ebx*4]
	mov	DWORD PTR [esi+44], eax
	mov	edx, DWORD PTR [edi+176]
	shr	edx, cl
	add	edx, eax
	mov	DWORD PTR [esi+48], edx

; 1310 : 		}
; 1311 : 		break;
; 1312 : 	}
; 1313 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L1929:

; 1223 : 		break;
; 1224 : 	case 0x60:
; 1225 : 		slot = slot_array[r&0x1f];

	and	edx, 31					; 0000001fH
	mov	ecx, DWORD PTR _slot_array[edx*4]

; 1226 : 		if(slot < 0) return;

	test	ecx, ecx
	jl	$L1948

; 1227 : 		set_ar_dr(OPL,slot,v);

	mov	eax, ecx
	and	ecx, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	lea	edx, DWORD PTR [eax+eax*2]
	shl	edx, 3
	sub	edx, eax
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	test	ebx, -16				; fffffff0H
	lea	eax, DWORD PTR [eax+eax*2]

; 1308 : 
; 1309 : 			CH->SLOT[slot&1].wavetable = (v&0x03)*SIN_LEN;

	lea	ecx, DWORD PTR [esi+eax*4]
	lea	eax, DWORD PTR [ecx+edx*8]
	je	SHORT $L2363
	mov	esi, ebx
	sar	esi, 2
	and	esi, -4					; fffffffcH
	add	esi, 16					; 00000010H
	jmp	SHORT $L2364

; 1227 : 		set_ar_dr(OPL,slot,v);

$L2363:
	xor	esi, esi
$L2364:
	xor	edx, edx
	mov	DWORD PTR [eax], esi
	mov	dl, BYTE PTR [eax+14]
	mov	edi, edx
	add	esi, edi
	cmp	esi, 78					; 0000004eH
	jae	SHORT $L2370
	mov	cl, BYTE PTR _eg_rate_shift[esi]
	mov	BYTE PTR [eax+60], cl
	mov	dl, BYTE PTR _eg_rate_select[esi]
	mov	BYTE PTR [eax+61], dl
	jmp	SHORT $L2371
$L2370:
	mov	BYTE PTR [eax+60], 0
	mov	BYTE PTR [eax+61], 104			; 00000068H
$L2371:
	and	ebx, 15					; 0000000fH
	je	SHORT $L2365
	lea	ecx, DWORD PTR [ebx*4+16]
	jmp	SHORT $L2366
$L2365:
	xor	ecx, ecx
$L2366:
	mov	DWORD PTR [eax+4], ecx
	mov	dl, BYTE PTR _eg_rate_shift[edi+ecx]
	mov	BYTE PTR [eax+62], dl
	mov	cl, BYTE PTR _eg_rate_select[edi+ecx]
	mov	BYTE PTR [eax+63], cl

; 1310 : 		}
; 1311 : 		break;
; 1312 : 	}
; 1313 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L1931:

; 1228 : 		break;
; 1229 : 	case 0x80:
; 1230 : 		slot = slot_array[r&0x1f];

	and	edx, 31					; 0000001fH
	mov	ecx, DWORD PTR _slot_array[edx*4]

; 1231 : 		if(slot < 0) return;

	test	ecx, ecx
	jl	$L1948

; 1232 : 		set_sl_rr(OPL,slot,v);

	mov	eax, ecx
	and	ecx, 1
	cdq
	sub	eax, edx
	sar	eax, 1
	lea	edx, DWORD PTR [eax+eax*2]
	shl	edx, 3
	sub	edx, eax
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax+eax*2]

; 1308 : 
; 1309 : 			CH->SLOT[slot&1].wavetable = (v&0x03)*SIN_LEN;

	lea	ecx, DWORD PTR [esi+eax*4]
	lea	eax, DWORD PTR [ecx+edx*8]
	mov	edx, ebx
	sar	edx, 4
	and	ebx, 15					; 0000000fH
	mov	ecx, DWORD PTR _sl_tab[edx*4]
	mov	DWORD PTR [eax+56], ecx
	je	SHORT $L2376

; 1232 : 		set_sl_rr(OPL,slot,v);

	lea	ecx, DWORD PTR [ebx*4+16]
	jmp	SHORT $L2377
$L2376:
	xor	ecx, ecx
$L2377:
	xor	edx, edx
	mov	DWORD PTR [eax+8], ecx
	mov	dl, BYTE PTR [eax+14]
	add	ecx, edx
	mov	dl, BYTE PTR _eg_rate_shift[ecx]
	mov	BYTE PTR [eax+64], dl
	mov	cl, BYTE PTR _eg_rate_select[ecx]
	mov	BYTE PTR [eax+65], cl

; 1310 : 		}
; 1311 : 		break;
; 1312 : 	}
; 1313 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L1933:

; 1233 : 		break;
; 1234 : 	case 0xa0:
; 1235 : 		if (r == 0xbd)			/* am depth, vibrato depth, r,bd,sd,tom,tc,hh */

	cmp	edx, 189				; 000000bdH
	jne	SHORT $L1934

; 1236 : 		{
; 1237 : 			OPL->lfo_am_depth = v & 0x80;

	mov	dl, bl

; 1238 : 			OPL->lfo_pm_depth_range = (v&0x40) ? 8 : 0;

	shr	ebx, 3
	and	dl, 128					; 00000080H
	and	bl, 8
	mov	BYTE PTR [esi+5768], dl
	mov	BYTE PTR [esi+5769], bl

; 1310 : 		}
; 1311 : 		break;
; 1312 : 	}
; 1313 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L1934:

; 1239 : 			return;
; 1240 : 		}
; 1241 : 		/* keyon,block,fnum */
; 1242 : 		if( (r&0x0f) > 8) return;

	mov	eax, edx
	and	eax, 15					; 0000000fH
	cmp	eax, 8
	jg	$L1948

; 1243 : 		CH = &OPL->P_CH[r&0x0f];

	lea	ecx, DWORD PTR [eax+eax*2]
	shl	ecx, 3
	sub	ecx, eax

; 1244 : 		if(!(r&0x10))

	test	dl, 16					; 00000010H
	lea	edi, DWORD PTR [esi+ecx*8]
	jne	SHORT $L1936

; 1245 : 		{	/* a0-a8 */
; 1246 : 			block_fnum  = (CH->block_fnum&0x1f00) | v;

	mov	eax, DWORD PTR [edi+168]
	and	eax, 7936				; 00001f00H
	or	eax, ebx

; 1247 : 		}
; 1248 : 		else

	jmp	$L2401
$L1936:

; 1249 : 		{	/* b0-b8 */
; 1250 : 			block_fnum = ((v&0x1f)<<8) | (CH->block_fnum&0xff);

	mov	edx, DWORD PTR [edi+168]
	mov	eax, ebx

; 1251 : 
; 1252 : 			if(v&0x20)
; 1253 : 			{
; 1254 : 				FM_KEYON (&CH->SLOT[SLOT1], 1);

	mov	ecx, DWORD PTR [edi+68]
	and	eax, 31					; 0000001fH
	shl	eax, 8
	and	edx, 255				; 000000ffH
	or	eax, edx
	test	bl, 32					; 00000020H
	je	SHORT $L1938
	xor	edx, edx
	mov	bl, 4
	cmp	ecx, edx
	jne	SHORT $L2384
	mov	DWORD PTR [edi+16], edx
	mov	BYTE PTR [edi+42], bl
$L2384:
	or	ecx, 1
	mov	DWORD PTR [edi+68], ecx

; 1255 : 				FM_KEYON (&CH->SLOT[SLOT2], 1);

	mov	ecx, DWORD PTR [edi+152]
	cmp	ecx, edx
	jne	SHORT $L2388
	mov	DWORD PTR [edi+100], edx
	mov	BYTE PTR [edi+126], bl
$L2388:
	or	ecx, 1
	mov	DWORD PTR [edi+152], ecx

; 1256 : 			}
; 1257 : 			else

	jmp	SHORT $L2401
$L1938:

; 1258 : 			{
; 1259 : 				FM_KEYOFF(&CH->SLOT[SLOT1],~1);

	test	ecx, ecx
	je	SHORT $L2395
	and	ecx, -2					; fffffffeH
	mov	DWORD PTR [edi+68], ecx
	jne	SHORT $L2395
	cmp	BYTE PTR [edi+42], 1
	jbe	SHORT $L2395
	mov	BYTE PTR [edi+42], 1
$L2395:

; 1260 : 				FM_KEYOFF(&CH->SLOT[SLOT2],~1);

	mov	ecx, DWORD PTR [edi+152]
	test	ecx, ecx
	je	SHORT $L2401
	and	ecx, -2					; fffffffeH
	mov	DWORD PTR [edi+152], ecx
	jne	SHORT $L2401
	cmp	BYTE PTR [edi+126], 1
	jbe	SHORT $L2401
	mov	BYTE PTR [edi+126], 1
$L2401:

; 1261 : 			}
; 1262 : 		}
; 1263 : 		/* update */
; 1264 : 		if(CH->block_fnum != (UINT32)block_fnum)

	cmp	DWORD PTR [edi+168], eax
	je	$L1948

; 1265 : 		{
; 1266 : 			UINT8 block  = block_fnum >> 10;
; 1267 : 
; 1268 : 			CH->block_fnum = block_fnum;
; 1269 : 
; 1270 : 			CH->ksl_base = ksl_tab[block_fnum>>6];

	mov	ecx, eax
	mov	DWORD PTR [edi+168], eax
	sar	ecx, 6
	mov	edx, DWORD PTR _ksl_tab[ecx*4]

; 1271 : 			CH->fc       = OPL->fn_tab[block_fnum&0x03ff] >> (7-block);

	mov	ecx, 7
	mov	DWORD PTR [edi+176], edx
	mov	edx, eax
	sar	edx, 10					; 0000000aH
	sub	ecx, edx
	mov	edx, eax
	and	edx, 1023				; 000003ffH
	mov	edx, DWORD PTR [esi+edx*4+1672]
	shr	edx, cl

; 1272 : 
; 1273 : 			/* BLK 2,1,0 bits -> bits 3,2,1 of kcode */
; 1274 : 			CH->kcode    = (CH->block_fnum&0x1c00)>>9;

	mov	ecx, eax
	shr	ecx, 9
	mov	DWORD PTR [edi+172], edx
	mov	dl, cl
	and	dl, 14					; 0000000eH
	mov	BYTE PTR [edi+180], dl

; 1275 : 
; 1276 : 			 /* the info below is actually opposite to what is stated in the Manuals (verifed on real YM3812) */
; 1277 : 			/* if notesel == 0 -> lsb of kcode is bit 10 (MSB) of fnum  */
; 1278 : 			/* if notesel == 1 -> lsb of kcode is bit 9 (MSB-1) of fnum */
; 1279 : 			if (OPL->mode&0x40)

	mov	bl, BYTE PTR [esi+5832]
	test	bl, 64					; 00000040H
	je	SHORT $L1943

; 1280 : 				CH->kcode |= (CH->block_fnum&0x100)>>8;	/* notesel == 1 */

	shr	eax, 8
	and	al, 1
	or	al, dl
	mov	BYTE PTR [edi+180], al

; 1281 : 			else

	jmp	SHORT $L1944
$L1943:

; 1282 : 				CH->kcode |= (CH->block_fnum&0x200)>>9;	/* notesel == 0 */

	and	cl, 1
	or	cl, dl
	mov	BYTE PTR [edi+180], cl
$L1944:

; 1283 : 
; 1284 : 			/* refresh Total Level in both SLOTs of this channel */
; 1285 : 			CH->SLOT[SLOT1].TLL = CH->SLOT[SLOT1].TL + (CH->ksl_base>>CH->SLOT[SLOT1].ksl);

	mov	eax, DWORD PTR [edi+176]
	mov	cl, BYTE PTR [edi+13]
	mov	esi, DWORD PTR [edi+44]
	mov	edx, eax
	shr	edx, cl

; 1286 : 			CH->SLOT[SLOT2].TLL = CH->SLOT[SLOT2].TL + (CH->ksl_base>>CH->SLOT[SLOT2].ksl);

	mov	cl, BYTE PTR [edi+97]
	shr	eax, cl
	mov	ecx, DWORD PTR [edi+128]
	add	edx, esi
	mov	DWORD PTR [edi+48], edx

; 1287 : 
; 1288 : 			/* refresh frequency counter in both SLOTs of this channel */
; 1289 : 			CALC_FCSLOT(CH,&CH->SLOT[SLOT1]);

	mov	edx, edi
	add	eax, ecx
	mov	ecx, edi
	mov	DWORD PTR [edi+132], eax
	call	?CALC_FCSLOT@@YIXPAUOPL_CH@@PAUOPL_SLOT@@@Z ; CALC_FCSLOT

; 1290 : 			CALC_FCSLOT(CH,&CH->SLOT[SLOT2]);

	lea	edx, DWORD PTR [edi+84]
	mov	ecx, edi
	call	?CALC_FCSLOT@@YIXPAUOPL_CH@@PAUOPL_SLOT@@@Z ; CALC_FCSLOT

; 1310 : 		}
; 1311 : 		break;
; 1312 : 	}
; 1313 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L1945:

; 1291 : 		}
; 1292 : 		break;
; 1293 : 	case 0xc0:
; 1294 : 		/* FB,C */
; 1295 : 		if( (r&0x0f) > 8) return;

	and	edx, 15					; 0000000fH
	cmp	edx, 8
	jg	SHORT $L1948

; 1296 : 		CH = &OPL->P_CH[r&0x0f];

	lea	eax, DWORD PTR [edx+edx*2]
	shl	eax, 3
	sub	eax, edx
	lea	ecx, DWORD PTR [esi+eax*8]

; 1297 : 		CH->SLOT[SLOT1].FB  = (v>>1)&7 ? ((v>>1)&7) + 7 : 0;

	mov	eax, ebx
	sar	eax, 1
	and	eax, 7
	je	SHORT $L2301
	add	eax, 7
	jmp	SHORT $L2302
$L2301:
	xor	eax, eax
$L2302:

; 1298 : 		CH->SLOT[SLOT1].CON = v&1;

	and	bl, 1
	mov	BYTE PTR [ecx+24], al
	mov	BYTE PTR [ecx+40], bl

; 1299 : 		CH->SLOT[SLOT1].connect1 = CH->SLOT[SLOT1].CON ? &output[0] : &phase_modulation;

	mov	eax, OFFSET FLAT:_output
	jne	SHORT $L2304
	mov	eax, OFFSET FLAT:_phase_modulation
$L2304:
	mov	DWORD PTR [ecx+28], eax

; 1310 : 		}
; 1311 : 		break;
; 1312 : 	}
; 1313 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L1947:

; 1300 : 		break;
; 1301 : 	case 0xe0: /* waveform select */
; 1302 : 		/* simply ignore write to the waveform select register if selecting not enabled in test register */
; 1303 : 		if(OPL->wavesel)

	mov	al, BYTE PTR [esi+5788]
	test	al, al
	je	SHORT $L1948

; 1304 : 		{
; 1305 : 			slot = slot_array[r&0x1f];

	and	edx, 31					; 0000001fH
	mov	ecx, DWORD PTR _slot_array[edx*4]

; 1306 : 			if(slot < 0) return;

	test	ecx, ecx
	jl	SHORT $L1948

; 1307 : 			CH = &OPL->P_CH[slot/2];

	mov	eax, ecx

; 1308 : 
; 1309 : 			CH->SLOT[slot&1].wavetable = (v&0x03)*SIN_LEN;

	and	ecx, 1
	cdq
	sub	eax, edx
	and	ebx, 3
	sar	eax, 1
	shl	ebx, 10					; 0000000aH
	lea	edx, DWORD PTR [eax+eax*2]
	shl	edx, 3
	sub	edx, eax
	lea	eax, DWORD PTR [ecx*8]
	sub	eax, ecx
	lea	eax, DWORD PTR [eax+eax*2]
	lea	ecx, DWORD PTR [esi+eax*4]
	mov	DWORD PTR [ecx+edx*8+80], ebx
$L1948:

; 1310 : 		}
; 1311 : 		break;
; 1312 : 	}
; 1313 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	3
$L2408:
	DD	$L1903
	DD	$L1925
	DD	$L1927
	DD	$L1929
	DD	$L1931
	DD	$L1933
	DD	$L1945
	DD	$L1947
	DD	$L1948
$L2403:
	DB	0
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	1
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	2
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	3
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	4
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	5
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	6
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	8
	DB	7
	npad	3
$L2409:
	DD	$L1908
	DD	$L1910
	DD	$L1911
	DD	$L1912
?OPLWriteReg@@YIXPAUfm_opl_f@@HH@Z ENDP			; OPLWriteReg
_TEXT	ENDS
PUBLIC	?YM3812Shutdown@@YIXXZ				; YM3812Shutdown
EXTRN	_free:NEAR
; Function compile flags: /Ogty
_TEXT	SEGMENT
?YM3812Shutdown@@YIXXZ PROC NEAR			; YM3812Shutdown

; 1560 : 	int i;
; 1561 : 
; 1562 : 	for (i = 0;i < YM3812NumChips; i++)

	mov	eax, DWORD PTR _YM3812NumChips
	push	esi
	push	edi
	xor	edi, edi
	xor	esi, esi
	cmp	eax, edi
	jle	SHORT $L2434
$L2055:

; 1563 : 	{
; 1564 : 		/* emulator shutdown */
; 1565 : 		OPLDestroy(OPL_YM3812[i]);

	mov	ecx, DWORD PTR _num_lock
	mov	eax, DWORD PTR _OPL_YM3812[esi*4]
	cmp	ecx, edi
	je	SHORT $L2433
	dec	ecx
	mov	DWORD PTR _num_lock, ecx
	jne	SHORT $L2425
$L2433:
	mov	DWORD PTR _cur_chip, edi
$L2425:
	push	eax
	call	_free
	mov	eax, DWORD PTR _YM3812NumChips
	add	esp, 4

; 1566 : 		OPL_YM3812[i] = NULL;

	mov	DWORD PTR _OPL_YM3812[esi*4], edi
	inc	esi
	cmp	esi, eax
	jl	SHORT $L2055
$L2434:

; 1567 : 	}
; 1568 : 	YM3812NumChips = 0;

	mov	DWORD PTR _YM3812NumChips, edi
	pop	edi
	pop	esi

; 1569 : }

	ret	0
?YM3812Shutdown@@YIXXZ ENDP				; YM3812Shutdown
_TEXT	ENDS
PUBLIC	?YM3812ResetChip@@YIXH@Z			; YM3812ResetChip
; Function compile flags: /Ogty
_TEXT	SEGMENT
?YM3812ResetChip@@YIXH@Z PROC NEAR			; YM3812ResetChip
; _which$ = ecx

; 1572 : 	OPLResetChip(OPL_YM3812[which]);

	mov	ecx, DWORD PTR _OPL_YM3812[ecx*4]
	jmp	?OPLResetChip@@YIXPAUfm_opl_f@@@Z	; OPLResetChip
?YM3812ResetChip@@YIXH@Z ENDP				; YM3812ResetChip
_TEXT	ENDS
PUBLIC	?YM3812Write@@YIHHHH@Z				; YM3812Write
; Function compile flags: /Ogty
_TEXT	SEGMENT
_v$ = 8
?YM3812Write@@YIHHHH@Z PROC NEAR			; YM3812Write
; _which$ = ecx
; _a$ = edx

; 1576 : {

	push	esi

; 1577 : 	return OPLWrite(OPL_YM3812[which], a, v);

	mov	esi, DWORD PTR _OPL_YM3812[ecx*4]
	test	dl, 1
	jne	SHORT $L2440
	mov	al, BYTE PTR _v$[esp]
	mov	BYTE PTR [esi+5829], al
	xor	eax, eax
	mov	al, BYTE PTR [esi+5830]
	pop	esi
	shr	eax, 7

; 1578 : }

	ret	4

; 1577 : 	return OPLWrite(OPL_YM3812[which], a, v);

$L2440:
	mov	eax, DWORD PTR [esi+5820]
	test	eax, eax
	je	SHORT $L2442
	mov	ecx, DWORD PTR [esi+5824]
	xor	edx, edx
	call	eax
$L2442:
	mov	ecx, DWORD PTR _v$[esp]
	xor	edx, edx
	mov	dl, BYTE PTR [esi+5829]
	push	ecx
	mov	ecx, esi
	call	?OPLWriteReg@@YIXPAUfm_opl_f@@HH@Z	; OPLWriteReg
	xor	eax, eax
	mov	al, BYTE PTR [esi+5830]
	pop	esi
	shr	eax, 7

; 1578 : }

	ret	4
?YM3812Write@@YIHHHH@Z ENDP				; YM3812Write
_TEXT	ENDS
PUBLIC	?YM3812Read@@YIEHH@Z				; YM3812Read
; Function compile flags: /Ogty
_TEXT	SEGMENT
?YM3812Read@@YIEHH@Z PROC NEAR				; YM3812Read
; _which$ = ecx
; _a$ = edx

; 1582 : 	/* YM3812 always returns bit2 and bit1 in HIGH state */
; 1583 : 	return OPLRead(OPL_YM3812[which], a) | 0x06 ;

	mov	ecx, DWORD PTR _OPL_YM3812[ecx*4]
	test	dl, 1
	jne	SHORT $L2448
	mov	al, BYTE PTR [ecx+5831]
	mov	dl, BYTE PTR [ecx+5830]
	or	al, 128					; 00000080H
	and	al, dl
	or	al, 6

; 1584 : }

	ret	0

; 1582 : 	/* YM3812 always returns bit2 and bit1 in HIGH state */
; 1583 : 	return OPLRead(OPL_YM3812[which], a) | 0x06 ;

$L2448:
	or	al, 255					; 000000ffH
	or	al, 6

; 1584 : }

	ret	0
?YM3812Read@@YIEHH@Z ENDP				; YM3812Read
_TEXT	ENDS
PUBLIC	?YM3812TimerOver@@YIHHH@Z			; YM3812TimerOver
; Function compile flags: /Ogty
_TEXT	SEGMENT
_c$ = -4
?YM3812TimerOver@@YIHHH@Z PROC NEAR			; YM3812TimerOver
; _which$ = ecx
; _c$ = edx

; 1586 : {

	push	ecx
	push	ebx
	push	ebp
	push	esi

; 1587 : 	return OPLTimerOver(OPL_YM3812[which], c);

	mov	esi, DWORD PTR _OPL_YM3812[ecx*4]
	push	edi
	mov	ebp, edx
	mov	dl, BYTE PTR [esi+5830]
	xor	edi, edi
	cmp	ebp, edi
	mov	DWORD PTR _c$[esp+20], ebp
	je	SHORT $L2542
	or	dl, 32					; 00000020H
	mov	al, dl
	mov	BYTE PTR [esi+5830], dl
	test	al, al
	js	$L2510
	test	BYTE PTR [esi+5831], al
	je	$L2510
	or	al, 128					; 00000080H
	mov	BYTE PTR [esi+5830], al
	mov	eax, DWORD PTR [esi+5812]
	cmp	eax, edi
	je	$L2510
	mov	ecx, DWORD PTR [esi+5816]
	mov	edx, 1
	call	eax
	jmp	$L2510
$L2542:
	or	dl, 64					; 00000040H
	mov	ebx, 1
	mov	al, dl
	mov	BYTE PTR [esi+5830], dl
	test	al, al
	js	SHORT $L2522
	test	BYTE PTR [esi+5831], al
	je	SHORT $L2522
	or	al, 128					; 00000080H
	mov	BYTE PTR [esi+5830], al
	mov	eax, DWORD PTR [esi+5812]
	cmp	eax, edi
	je	SHORT $L2522
	mov	ecx, DWORD PTR [esi+5816]
	mov	edx, ebx
	call	eax
$L2522:
	mov	al, BYTE PTR [esi+5832]
	test	al, al
	jns	$L2510
	mov	eax, DWORD PTR [esi+5820]
	cmp	eax, edi
	je	SHORT $L2507
	mov	ecx, DWORD PTR [esi+5824]
	xor	edx, edx
	call	eax
$L2507:
	lea	eax, DWORD PTR [esi+152]
	mov	ebp, 9
	mov	edx, 4
$L2508:
	mov	ecx, DWORD PTR [eax-84]
	cmp	ecx, edi
	jne	SHORT $L2526
	mov	DWORD PTR [eax-136], edi
	mov	BYTE PTR [eax-110], dl
$L2526:
	or	ecx, edx
	mov	DWORD PTR [eax-84], ecx
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, edi
	jne	SHORT $L2529
	mov	DWORD PTR [eax-52], edi
	mov	BYTE PTR [eax-26], dl
$L2529:
	or	ecx, edx
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [eax-84]
	cmp	ecx, edi
	je	SHORT $L2534
	and	ecx, -5					; fffffffbH
	mov	DWORD PTR [eax-84], ecx
	jne	SHORT $L2534
	cmp	BYTE PTR [eax-110], bl
	jbe	SHORT $L2534
	mov	BYTE PTR [eax-110], bl
$L2534:
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, edi
	je	SHORT $L2509
	and	ecx, -5					; fffffffbH
	mov	DWORD PTR [eax], ecx
	jne	SHORT $L2509
	cmp	BYTE PTR [eax-26], bl
	jbe	SHORT $L2509
	mov	BYTE PTR [eax-26], bl
$L2509:
	add	eax, 184				; 000000b8H
	dec	ebp
	jne	SHORT $L2508
	mov	ebp, DWORD PTR _c$[esp+20]
$L2510:
	mov	eax, DWORD PTR [esi+5804]
	cmp	eax, edi
	je	SHORT $L2511
	fild	DWORD PTR [esi+ebp*4+5792]
	mov	ecx, DWORD PTR [esi+5808]
	sub	esp, 8
	add	ecx, ebp
	fmul	QWORD PTR [esi+5856]
	fstp	QWORD PTR [esp]
	call	eax
$L2511:
	xor	eax, eax
	pop	edi
	mov	al, BYTE PTR [esi+5830]
	pop	esi
	pop	ebp
	pop	ebx
	shr	eax, 7

; 1588 : }

	pop	ecx
	ret	0
?YM3812TimerOver@@YIHHH@Z ENDP				; YM3812TimerOver
_TEXT	ENDS
PUBLIC	?YM3812SetTimerHandler@@YIXHP6IXHN@ZH@Z		; YM3812SetTimerHandler
; Function compile flags: /Ogty
_TEXT	SEGMENT
_channelOffset$ = 8
?YM3812SetTimerHandler@@YIXHP6IXHN@ZH@Z PROC NEAR	; YM3812SetTimerHandler
; _which$ = ecx
; _TimerHandler$ = edx

; 1592 : 	OPLSetTimerHandler(OPL_YM3812[which], TimerHandler, channelOffset);

	mov	eax, DWORD PTR _OPL_YM3812[ecx*4]
	mov	ecx, DWORD PTR _channelOffset$[esp-4]
	mov	DWORD PTR [eax+5804], edx
	mov	DWORD PTR [eax+5808], ecx

; 1593 : }

	ret	4
?YM3812SetTimerHandler@@YIXHP6IXHN@ZH@Z ENDP		; YM3812SetTimerHandler
_TEXT	ENDS
PUBLIC	?YM3812SetIRQHandler@@YIXHP6IXHH@ZH@Z		; YM3812SetIRQHandler
; Function compile flags: /Ogty
_TEXT	SEGMENT
_param$ = 8
?YM3812SetIRQHandler@@YIXHP6IXHH@ZH@Z PROC NEAR		; YM3812SetIRQHandler
; _which$ = ecx
; _IRQHandler$ = edx

; 1596 : 	OPLSetIRQHandler(OPL_YM3812[which], IRQHandler, param);

	mov	eax, DWORD PTR _OPL_YM3812[ecx*4]
	mov	ecx, DWORD PTR _param$[esp-4]
	mov	DWORD PTR [eax+5812], edx
	mov	DWORD PTR [eax+5816], ecx

; 1597 : }

	ret	4
?YM3812SetIRQHandler@@YIXHP6IXHH@ZH@Z ENDP		; YM3812SetIRQHandler
_TEXT	ENDS
PUBLIC	?YM3812SetUpdateHandler@@YIXHP6IXHH@ZH@Z	; YM3812SetUpdateHandler
; Function compile flags: /Ogty
_TEXT	SEGMENT
_param$ = 8
?YM3812SetUpdateHandler@@YIXHP6IXHH@ZH@Z PROC NEAR	; YM3812SetUpdateHandler
; _which$ = ecx
; _UpdateHandler$ = edx

; 1600 : 	OPLSetUpdateHandler(OPL_YM3812[which], UpdateHandler, param);

	mov	eax, DWORD PTR _OPL_YM3812[ecx*4]
	mov	ecx, DWORD PTR _param$[esp-4]
	mov	DWORD PTR [eax+5820], edx
	mov	DWORD PTR [eax+5824], ecx

; 1601 : }

	ret	4
?YM3812SetUpdateHandler@@YIXHP6IXHH@ZH@Z ENDP		; YM3812SetUpdateHandler
_TEXT	ENDS
PUBLIC	?YM3812UpdateOne@@YIXHPAHH@Z			; YM3812UpdateOne
; Function compile flags: /Ogty
_TEXT	SEGMENT
_buffer$ = -4
_length$ = 8
_eg_timer_bak$ = -8
_eg_cnt_bak$ = -12
_lfo_am_cnt_out$ = -24
_eg_timer_out$ = -20
_eg_cnt_out$ = -16
?YM3812UpdateOne@@YIXHPAHH@Z PROC NEAR			; YM3812UpdateOne
; _which$ = ecx
; _buffer$ = edx

; 1612 : {

	sub	esp, 24					; 00000018H

; 1613 : 	FM_OPL		*OPL = OPL_YM3812[which];
; 1614 : 	INT32		*buf = buffer;
; 1615 : 	int i;
; 1616 : 
; 1617 : 	if( (void *)OPL != cur_chip )

	mov	eax, DWORD PTR _cur_chip
	push	ebx
	push	esi
	mov	esi, DWORD PTR _OPL_YM3812[ecx*4]
	cmp	esi, eax
	push	edi
	mov	DWORD PTR _buffer$[esp+36], edx
	je	SHORT $L2098

; 1618 : 	{
; 1619 : 		cur_chip = (void *)OPL;

	mov	DWORD PTR _cur_chip, esi
$L2098:

; 1620 : 	}
; 1621 : #if 0
; 1622 : 	for( i=0; i < length ; i++ )
; 1623 : 	{
; 1624 : 		output[0] = 0;
; 1625 : 
; 1626 : 		advance_lfo(OPL);
; 1627 : 
; 1628 : 		/* FM part */
; 1629 : 		for (int j = 0; j <= 8; ++j)
; 1630 : 		{
; 1631 : 			OPL_CALC_CH(&OPL->P_CH[j]);
; 1632 : 		}
; 1633 : 		// [RH] Just add to the output. Clamping will happen later.
; 1634 : 		buf[i] += output[0];
; 1635 : 		advance(OPL);
; 1636 : 	}
; 1637 : #else
; 1638 : 	UINT32 lfo_am_cnt_bak = OPL->lfo_am_cnt;

	mov	ebx, DWORD PTR [esi+5772]

; 1639 : 	UINT32 eg_timer_bak = OPL->eg_timer;

	mov	eax, DWORD PTR [esi+1660]

; 1640 : 	UINT32 eg_cnt_bak = OPL->eg_cnt;

	mov	ecx, DWORD PTR [esi+1656]
	mov	DWORD PTR _eg_timer_bak$[esp+36], eax
	mov	DWORD PTR _eg_cnt_bak$[esp+36], ecx

; 1641 : 
; 1642 : 	UINT32 lfo_am_cnt_out = lfo_am_cnt_bak;

	mov	DWORD PTR _lfo_am_cnt_out$[esp+36], ebx

; 1643 : 	UINT32 eg_timer_out = eg_timer_bak;

	mov	DWORD PTR _eg_timer_out$[esp+36], eax

; 1644 : 	UINT32 eg_cnt_out = eg_cnt_bak;

	mov	DWORD PTR _eg_cnt_out$[esp+36], ecx

; 1645 : 
; 1646 : 	for (i = 0; i <= 8; ++i)

	xor	edi, edi
	jmp	SHORT $L2106
$L2567:
	mov	ecx, DWORD PTR _eg_cnt_bak$[esp+36]
	mov	eax, DWORD PTR _eg_timer_bak$[esp+36]
$L2106:

; 1647 : 	{
; 1648 : 		OPL->lfo_am_cnt = lfo_am_cnt_bak;
; 1649 : 		OPL->eg_timer = eg_timer_bak;

	mov	DWORD PTR [esi+1660], eax

; 1650 : 		OPL->eg_cnt = eg_cnt_bak;
; 1651 : 		if (CalcVoice (OPL, i, buf, length))

	mov	eax, DWORD PTR _length$[esp+32]
	mov	DWORD PTR [esi+1656], ecx
	mov	ecx, DWORD PTR _buffer$[esp+36]
	push	eax
	push	ecx
	mov	edx, edi
	mov	ecx, esi
	mov	DWORD PTR [esi+5772], ebx
	call	?CalcVoice@@YI_NPAUfm_opl_f@@HPAHH@Z	; CalcVoice
	test	al, al
	je	SHORT $L2107

; 1652 : 		{
; 1653 : 			lfo_am_cnt_out = OPL->lfo_am_cnt;

	mov	edx, DWORD PTR [esi+5772]

; 1654 : 			eg_timer_out = OPL->eg_timer;

	mov	eax, DWORD PTR [esi+1660]

; 1655 : 			eg_cnt_out = OPL->eg_cnt;

	mov	ecx, DWORD PTR [esi+1656]
	mov	DWORD PTR _lfo_am_cnt_out$[esp+36], edx
	mov	DWORD PTR _eg_timer_out$[esp+36], eax
	mov	DWORD PTR _eg_cnt_out$[esp+36], ecx
$L2107:
	inc	edi
	cmp	edi, 8
	jle	SHORT $L2567

; 1656 : 		}
; 1657 : 	}
; 1658 : 
; 1659 : 	OPL->lfo_am_cnt = lfo_am_cnt_out;

	mov	edx, DWORD PTR _lfo_am_cnt_out$[esp+36]

; 1660 : 	OPL->eg_timer = eg_timer_out;

	mov	eax, DWORD PTR _eg_timer_out$[esp+36]

; 1661 : 	OPL->eg_cnt = eg_cnt_out;

	mov	ecx, DWORD PTR _eg_cnt_out$[esp+36]
	mov	DWORD PTR [esi+5772], edx
	mov	DWORD PTR [esi+1660], eax
	mov	DWORD PTR [esi+1656], ecx
	pop	edi
	pop	esi
	pop	ebx

; 1662 : #endif
; 1663 : }

	add	esp, 24					; 00000018H
	ret	4
?YM3812UpdateOne@@YIXHPAHH@Z ENDP			; YM3812UpdateOne
_TEXT	ENDS
_BSS	SEGMENT
_LFO_AM	DD	01H DUP (?)
_LFO_PM	DD	01H DUP (?)
; Function compile flags: /Ogty
_BSS	ENDS
_TEXT	SEGMENT
_buffer$ = 8
_length$ = 12
_i$ = -16
_tmp$2123 = -12
?CalcVoice@@YI_NPAUfm_opl_f@@HPAHH@Z PROC NEAR		; CalcVoice
; _OPL$ = ecx
; _voice$ = edx

; 1669 : {

	sub	esp, 16					; 00000010H

; 1670 : 	OPL_CH *const CH = &OPL->P_CH[voice];

	lea	eax, DWORD PTR [edx+edx*2]
	shl	eax, 3
	push	ebp
	push	esi
	mov	esi, ecx
	sub	eax, edx
	lea	ebp, DWORD PTR [esi+eax*8]

; 1671 : 	int i, j;
; 1672 : 
; 1673 : 	if (CH->SLOT[0].state == EG_OFF && CH->SLOT[1].state == EG_OFF)

	mov	al, BYTE PTR [esi+eax*8+42]
	test	al, al
	jne	SHORT $L2119
	mov	al, BYTE PTR [ebp+126]
	test	al, al
	jne	SHORT $L2119
	pop	esi

; 1674 : 	{ // Voice is not playing, so don't do anything for it
; 1675 : 		return false;

	xor	al, al
	pop	ebp

; 1854 : }

	add	esp, 16					; 00000010H
	ret	8
$L2119:

; 1676 : 	}
; 1677 : 
; 1678 : 	for (i = 0; i < length; ++i)

	mov	eax, DWORD PTR _length$[esp+20]
	push	edi
	xor	edi, edi
	cmp	eax, edi
	mov	DWORD PTR _i$[esp+28], edi
	jle	$L2122
	push	ebx
	mov	ebx, 511				; 000001ffH
	jmp	SHORT $L2120
$L2579:
	xor	edi, edi
$L2120:

; 1679 : 	{
; 1680 : 		// advance_lfo
; 1681 : 		UINT8 tmp;
; 1682 : 
; 1683 : 		/* LFO */
; 1684 : 		OPL->lfo_am_cnt += OPL->lfo_am_inc;

	mov	ecx, DWORD PTR [esi+5776]
	mov	edx, DWORD PTR [esi+5772]
	add	edx, ecx
	mov	eax, edx
	mov	DWORD PTR [esi+5772], edx

; 1685 : 		if (OPL->lfo_am_cnt >= (UINT32)(LFO_AM_TAB_ELEMENTS<<LFO_SH) )	/* lfo_am_table is 210 elements long */

	cmp	eax, -771751936				; d2000000H
	jb	SHORT $L2125

; 1686 : 			OPL->lfo_am_cnt -= (LFO_AM_TAB_ELEMENTS<<LFO_SH);

	add	eax, 771751936				; 2e000000H
	mov	DWORD PTR [esi+5772], eax
$L2125:

; 1687 : 
; 1688 : 		tmp = lfo_am_table[ OPL->lfo_am_cnt >> LFO_SH ];

	xor	edx, edx
	mov	dl, BYTE PTR [esi+5775]
	mov	al, BYTE PTR _lfo_am_table[edx]
	mov	BYTE PTR _tmp$2123[esp+32], al

; 1689 : 
; 1690 : 		if (OPL->lfo_am_depth)

	mov	al, BYTE PTR [esi+5768]
	test	al, al
	je	SHORT $L2126

; 1691 : 			LFO_AM = tmp;

	mov	ecx, DWORD PTR _tmp$2123[esp+32]
	and	ecx, 255				; 000000ffH
	mov	DWORD PTR _LFO_AM, ecx

; 1692 : 		else

	jmp	SHORT $L2127
$L2126:

; 1693 : 			LFO_AM = tmp>>2;

	mov	edx, DWORD PTR _tmp$2123[esp+32]
	and	edx, 255				; 000000ffH
	shr	edx, 2
	mov	DWORD PTR _LFO_AM, edx
$L2127:

; 1694 : 
; 1695 : 		OPL->lfo_pm_cnt += OPL->lfo_pm_inc;

	mov	eax, DWORD PTR [esi+5784]
	mov	ecx, DWORD PTR [esi+5780]
	add	ecx, eax

; 1696 : 		LFO_PM = ((OPL->lfo_pm_cnt>>LFO_SH) & 7) | OPL->lfo_pm_depth_range;

	xor	edx, edx
	mov	dl, BYTE PTR [esi+5769]
	mov	DWORD PTR [esi+5780], ecx
	mov	cl, BYTE PTR [esi+5783]

; 1697 : 
; 1698 : 		// OPL_CALC_CH
; 1699 : 		OPL_SLOT *SLOT;
; 1700 : 		unsigned int env;
; 1701 : 		signed int out;
; 1702 : 		UINT32 p;
; 1703 : 
; 1704 : 		phase_modulation = 0;

	mov	DWORD PTR _phase_modulation, edi
	and	ecx, 7

; 1705 : 		output[0] = 0;

	mov	DWORD PTR _output, edi

; 1706 : 
; 1707 : 		/* SLOT 1 */
; 1708 : 		SLOT = &CH->SLOT[SLOT1];
; 1709 : 		env  = volume_calc(SLOT);

	mov	edi, DWORD PTR _LFO_AM
	or	ecx, edx
	mov	DWORD PTR _LFO_PM, ecx
	mov	eax, DWORD PTR [ebp+72]
	mov	edx, DWORD PTR [ebp+52]
	mov	ecx, DWORD PTR [ebp+48]
	and	eax, edi

; 1710 : 		out  = SLOT->op1_out[0] + SLOT->op1_out[1];
; 1711 : 		SLOT->op1_out[0] = SLOT->op1_out[1];
; 1712 : 		*SLOT->connect1 += SLOT->op1_out[0];

	mov	edi, DWORD PTR [ebp+28]
	add	eax, edx
	mov	edx, DWORD PTR [ebp+32]
	add	eax, ecx
	mov	ecx, DWORD PTR [ebp+36]
	mov	DWORD PTR [ebp+32], ecx
	add	DWORD PTR [edi], ecx
	add	edx, ecx

; 1713 : 		SLOT->op1_out[1] = 0;
; 1714 : 		if( env < ENV_QUIET )

	cmp	eax, 384				; 00000180H
	mov	DWORD PTR [ebp+36], 0
	jae	SHORT $L2133

; 1715 : 		{
; 1716 : 			if (!SLOT->FB)

	mov	cl, BYTE PTR [ebp+24]
	test	cl, cl
	jne	SHORT $L2134

; 1717 : 				out = 0;

	xor	edx, edx
$L2134:

; 1718 : 			p = (env<<4) + sin_tab[SLOT->wavetable + ((((SLOT->Cnt & ~FREQ_MASK) + (out<<SLOT->FB))>>FREQ_SH) & SIN_MASK)];

	shl	edx, cl
	mov	ecx, DWORD PTR [ebp+16]
	mov	edi, DWORD PTR [ebp+80]
	and	ecx, -65536				; ffff0000H
	shl	eax, 4
	add	edx, ecx
	shr	edx, 16					; 00000010H
	and	edx, 1023				; 000003ffH
	add	edx, edi
	add	eax, DWORD PTR _sin_tab[edx*4]

; 1719 : 			SLOT->op1_out[1] = p >= TL_TAB_LEN ? 0 : tl_tab[p];

	cmp	eax, 6144				; 00001800H
	jb	SHORT $L2570
	xor	eax, eax
	jmp	SHORT $L2571
$L2570:
	mov	eax, DWORD PTR _tl_tab[eax*4]
$L2571:
	mov	DWORD PTR [ebp+36], eax
$L2133:

; 1720 : 		}
; 1721 : 
; 1722 : 		/* SLOT 2 */
; 1723 : 		SLOT++;
; 1724 : 		env = volume_calc(SLOT);

	mov	eax, DWORD PTR [ebp+156]
	mov	ecx, DWORD PTR _LFO_AM
	mov	edi, DWORD PTR [ebp+136]
	mov	edx, DWORD PTR [ebp+132]
	and	eax, ecx
	add	eax, edi
	add	eax, edx

; 1725 : 		if( env < ENV_QUIET )

	cmp	eax, 384				; 00000180H
	jae	SHORT $L2136

; 1726 : 		{
; 1727 : 			p = (env<<4) + sin_tab[SLOT->wavetable + ((((signed int)((SLOT->Cnt & ~FREQ_MASK) + (phase_modulation<<16))) >> FREQ_SH ) & SIN_MASK) ];

	mov	edx, DWORD PTR [ebp+100]
	mov	ecx, DWORD PTR _phase_modulation
	mov	edi, DWORD PTR [ebp+164]
	and	edx, -65536				; ffff0000H
	shl	ecx, 16					; 00000010H
	add	edx, ecx

; 1728 : 			if (p < TL_TAB_LEN)
; 1729 : 			{
; 1730 : 				output[0] += tl_tab[p];

	mov	ecx, DWORD PTR _output
	sar	edx, 16					; 00000010H
	and	edx, 1023				; 000003ffH
	add	edx, edi
	shl	eax, 4
	add	eax, DWORD PTR _sin_tab[edx*4]
	cmp	eax, 6144				; 00001800H
	jae	SHORT $L2138
	add	ecx, DWORD PTR _tl_tab[eax*4]
	mov	DWORD PTR _output, ecx
$L2138:

; 1731 : 			}
; 1732 : 			// [RH] make the output louder.
; 1733 : 			buffer[i] += (output[0] + (output[0]>>1));

	mov	eax, DWORD PTR _buffer$[esp+28]
	mov	edx, ecx
	sar	edx, 1
	add	edx, ecx
	mov	ecx, DWORD PTR _i$[esp+32]
	add	DWORD PTR [eax+ecx*4], edx
$L2136:

; 1734 : 		}
; 1735 : 
; 1736 : 		// advance
; 1737 : 		OPL->eg_timer += OPL->eg_timer_add;

	mov	eax, DWORD PTR [esi+1664]
	mov	edi, DWORD PTR [esi+1660]
	add	edi, eax

; 1738 : 
; 1739 : 		while (OPL->eg_timer >= OPL->eg_timer_overflow)

	mov	eax, DWORD PTR [esi+1668]
	mov	ecx, edi
	mov	DWORD PTR [esi+1660], edi
	cmp	ecx, eax
	jb	$L2121
$L2140:

; 1740 : 		{
; 1741 : 			OPL->eg_timer -= OPL->eg_timer_overflow;

	mov	ecx, DWORD PTR [esi+1660]
	mov	DWORD PTR -8+[esp+32], 2
	sub	ecx, eax

; 1742 : 
; 1743 : 			OPL->eg_cnt++;

	mov	eax, DWORD PTR [esi+1656]
	inc	eax
	mov	DWORD PTR [esi+1660], ecx
	mov	DWORD PTR [esi+1656], eax
	lea	eax, DWORD PTR [ebp+60]
$L2142:

; 1744 : 
; 1745 : 			for (j = 0; j < 2; ++j)
; 1746 : 			{
; 1747 : 				OPL_SLOT *op  = &CH->SLOT[j];
; 1748 : 
; 1749 : 				/* Envelope Generator */
; 1750 : 				switch(op->state)
; 1751 : 				{

	xor	ecx, ecx
	mov	cl, BYTE PTR [eax-18]
	dec	ecx
	cmp	ecx, 3
	ja	$L2164
	jmp	DWORD PTR $L2584[ecx*4]
$L2150:

; 1752 : 				case EG_ATT:		/* attack phase */
; 1753 : 				{
; 1754 : 
; 1755 : 					if ( !(OPL->eg_cnt & ((1<<op->eg_sh_ar)-1) ) )

	xor	ecx, ecx
	mov	edx, DWORD PTR [esi+1656]
	mov	cl, BYTE PTR [eax]
	mov	edi, 1
	shl	edi, cl
	dec	edi
	test	edi, edx
	jne	$L2164

; 1756 : 					{
; 1757 : 						op->volume += (~op->volume *
; 1758 : 	                        					(eg_inc[op->eg_sel_ar + ((OPL->eg_cnt>>op->eg_sh_ar)&7)])
; 1759 :         										) >>3;

	mov	edi, DWORD PTR [eax-8]
	xor	ebx, ebx
	shr	edx, cl
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+1]
	and	edx, 7
	mov	bl, BYTE PTR _eg_inc[edx+ecx]
	mov	edx, edi
	not	edx
	imul	ebx, edx
	sar	ebx, 3
	lea	ecx, DWORD PTR [ebx+edi]

; 1760 : 
; 1761 : 						if (op->volume <= MIN_ATT_INDEX)
; 1762 : 						{
; 1763 : 							op->volume = MIN_ATT_INDEX;
; 1764 : 							op->state = EG_DEC;
; 1765 : 						}
; 1766 : 
; 1767 : 					}
; 1768 : 
; 1769 : 				}
; 1770 : 				break;

	mov	ebx, 511				; 000001ffH
	test	ecx, ecx
	mov	DWORD PTR [eax-8], ecx
	jg	$L2164
	mov	DWORD PTR [eax-8], 0
	mov	BYTE PTR [eax-18], 3
	jmp	$L2164
$L2153:

; 1771 : 
; 1772 : 				case EG_DEC:	/* decay phase */
; 1773 : 					if ( !(OPL->eg_cnt & ((1<<op->eg_sh_dr)-1) ) )

	xor	ecx, ecx
	mov	edx, DWORD PTR [esi+1656]
	mov	cl, BYTE PTR [eax+2]
	mov	edi, 1
	shl	edi, cl
	dec	edi
	test	edi, edx
	jne	$L2164

; 1774 : 					{
; 1775 : 						op->volume += eg_inc[op->eg_sel_dr + ((OPL->eg_cnt>>op->eg_sh_dr)&7)];

	shr	edx, cl
	mov	edi, DWORD PTR [eax-8]
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax+3]
	mov	DWORD PTR -4+[esp+32], ebx
	xor	ebx, ebx
	and	edx, 7
	mov	bl, BYTE PTR _eg_inc[edx+ecx]

; 1776 : 
; 1777 : 						if ( op->volume >= (INT32)op->sl )

	mov	edx, DWORD PTR [eax-4]
	add	edi, ebx
	mov	ebx, DWORD PTR -4+[esp+32]
	mov	ecx, edi
	mov	DWORD PTR [eax-8], edi
	cmp	ecx, edx
	jl	$L2164

; 1778 : 							op->state = EG_SUS;

	mov	BYTE PTR [eax-18], 2

; 1779 : 
; 1780 : 					}
; 1781 : 				break;

	jmp	$L2164
$L2157:

; 1782 : 
; 1783 : 				case EG_SUS:	/* sustain phase */
; 1784 : 
; 1785 : 					/* this is important behaviour:
; 1786 : 					one can change percusive/non-percussive modes on the fly and
; 1787 : 					the chip will remain in sustain phase - verified on real YM3812 */
; 1788 : 
; 1789 : 					if(op->eg_type)		/* non-percussive mode */

	mov	cl, BYTE PTR [eax-19]
	test	cl, cl
	jne	$L2164

; 1790 : 					{
; 1791 : 										/* do nothing */
; 1792 : 					}
; 1793 : 					else				/* percussive mode */
; 1794 : 					{
; 1795 : 						/* during sustain phase chip adds Release Rate (in percussive mode) */
; 1796 : 						if ( !(OPL->eg_cnt & ((1<<op->eg_sh_rr)-1) ) )

	xor	ecx, ecx
	mov	edx, DWORD PTR [esi+1656]
	mov	cl, BYTE PTR [eax+4]
	mov	edi, 1
	shl	edi, cl
	dec	edi
	test	edi, edx
	jne	SHORT $L2164

; 1797 : 						{
; 1798 : 							op->volume += eg_inc[op->eg_sel_rr + ((OPL->eg_cnt>>op->eg_sh_rr)&7)];

	shr	edx, cl
	xor	ecx, ecx
	mov	DWORD PTR -4+[esp+32], ebx
	mov	cl, BYTE PTR [eax+5]
	xor	ebx, ebx
	and	edx, 7
	mov	bl, BYTE PTR _eg_inc[edx+ecx]
	mov	edx, DWORD PTR [eax-8]
	add	edx, ebx
	mov	ebx, DWORD PTR -4+[esp+32]

; 1799 : 
; 1800 : 							if ( op->volume >= MAX_ATT_INDEX )

	mov	ecx, edx
	mov	DWORD PTR [eax-8], edx
	cmp	ecx, ebx
	jl	SHORT $L2164

; 1801 : 								op->volume = MAX_ATT_INDEX;
; 1802 : 						}
; 1803 : 						/* else do nothing in sustain phase */
; 1804 : 					}
; 1805 : 				break;

	jmp	SHORT $L2583
$L2162:

; 1806 : 
; 1807 : 				case EG_REL:	/* release phase */
; 1808 : 					if ( !(OPL->eg_cnt & ((1<<op->eg_sh_rr)-1) ) )

	xor	ecx, ecx
	mov	edx, DWORD PTR [esi+1656]
	mov	cl, BYTE PTR [eax+4]
	mov	edi, 1
	shl	edi, cl
	dec	edi
	test	edi, edx
	jne	SHORT $L2164

; 1809 : 					{
; 1810 : 						op->volume += eg_inc[op->eg_sel_rr + ((OPL->eg_cnt>>op->eg_sh_rr)&7)];

	shr	edx, cl
	xor	ecx, ecx
	mov	DWORD PTR -4+[esp+32], ebx
	mov	cl, BYTE PTR [eax+5]
	xor	ebx, ebx
	and	edx, 7
	mov	bl, BYTE PTR _eg_inc[edx+ecx]
	mov	edx, DWORD PTR [eax-8]
	add	edx, ebx
	mov	ebx, DWORD PTR -4+[esp+32]

; 1811 : 
; 1812 : 						if ( op->volume >= MAX_ATT_INDEX )

	mov	ecx, edx
	mov	DWORD PTR [eax-8], edx
	cmp	ecx, ebx
	jl	SHORT $L2164

; 1815 : 							op->state = EG_OFF;

	mov	BYTE PTR [eax-18], 0
$L2583:

; 1813 : 						{
; 1814 : 							op->volume = MAX_ATT_INDEX;

	mov	DWORD PTR [eax-8], ebx
$L2164:

; 1816 : 						}
; 1817 : 
; 1818 : 					}
; 1819 : 				break;
; 1820 : 
; 1821 : 				default:
; 1822 : 				break;
; 1823 : 				}
; 1824 : 
; 1825 : 				/* Phase Generator */
; 1826 : 				if(op->vib)

	mov	cl, BYTE PTR [eax+16]
	test	cl, cl
	je	SHORT $L2166

; 1827 : 				{
; 1828 : 					UINT8 block;
; 1829 : 					unsigned int block_fnum = CH->block_fnum;

	mov	edx, DWORD PTR [ebp+168]

; 1830 : 
; 1831 : 					unsigned int fnum_lfo   = (block_fnum&0x0380) >> 7;
; 1832 : 
; 1833 : 					signed int lfo_fn_table_index_offset = lfo_pm_table[LFO_PM + 16*fnum_lfo ];

	mov	edi, DWORD PTR _LFO_PM
	mov	ecx, edx
	shr	ecx, 7
	and	ecx, 7
	shl	ecx, 4
	movsx	ecx, BYTE PTR _lfo_pm_table[ecx+edi]

; 1834 : 
; 1835 : 					if (lfo_fn_table_index_offset)	/* LFO phase modulation active */

	test	ecx, ecx
	je	SHORT $L2171

; 1836 : 					{
; 1837 : 						block_fnum += lfo_fn_table_index_offset;

	add	edx, ecx

; 1838 : 						block = (block_fnum&0x1c00) >> 10;
; 1839 : 						op->Cnt += (OPL->fn_tab[block_fnum&0x03ff] >> (7-block)) * op->mul;//ok

	mov	ecx, 7
	mov	edi, edx
	and	edx, 1023				; 000003ffH
	shr	edi, 10					; 0000000aH
	mov	edx, DWORD PTR [esi+edx*4+1672]
	and	edi, 7
	sub	ecx, edi
	shr	edx, cl
	xor	ecx, ecx
	mov	cl, BYTE PTR [eax-45]
	imul	edx, ecx
	add	DWORD PTR [eax-44], edx

; 1840 : 					}
; 1841 : 					else	/* LFO phase modulation  = zero */

	jmp	SHORT $L2143
$L2171:

; 1842 : 					{
; 1843 : 						op->Cnt += op->Incr;

	mov	edx, DWORD PTR [eax-40]
	mov	ecx, DWORD PTR [eax-44]
	add	ecx, edx
	mov	DWORD PTR [eax-44], ecx

; 1844 : 					}
; 1845 : 				}
; 1846 : 				else	/* LFO phase modulation disabled for this operator */

	jmp	SHORT $L2143
$L2166:

; 1847 : 				{
; 1848 : 					op->Cnt += op->Incr;

	mov	ecx, DWORD PTR [eax-40]
	mov	edx, DWORD PTR [eax-44]
	add	edx, ecx
	mov	DWORD PTR [eax-44], edx
$L2143:
	mov	ecx, DWORD PTR -8+[esp+32]
	add	eax, 84					; 00000054H
	dec	ecx
	mov	DWORD PTR -8+[esp+32], ecx
	jne	$L2142
	mov	eax, DWORD PTR [esi+1668]
	mov	ecx, DWORD PTR [esi+1660]
	cmp	ecx, eax
	jae	$L2140
$L2121:

; 1676 : 	}
; 1677 : 
; 1678 : 	for (i = 0; i < length; ++i)

	mov	eax, DWORD PTR _i$[esp+32]
	mov	ecx, DWORD PTR _length$[esp+28]
	inc	eax
	cmp	eax, ecx
	mov	DWORD PTR _i$[esp+32], eax
	jl	$L2579
	pop	ebx
$L2122:
	pop	edi
	pop	esi

; 1849 : 				}
; 1850 : 			}
; 1851 : 		}
; 1852 : 	}
; 1853 : 	return true;

	mov	al, 1
	pop	ebp

; 1854 : }

	add	esp, 16					; 00000010H
	ret	8
	npad	2
$L2584:
	DD	$L2162
	DD	$L2157
	DD	$L2153
	DD	$L2150
?CalcVoice@@YI_NPAUfm_opl_f@@HPAHH@Z ENDP		; CalcVoice
_TEXT	ENDS
END
