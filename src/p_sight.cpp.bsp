//**************************************************************************
//**
//** p_sight.cpp : Heretic 2 : Raven Software, Corp.
//**
//** $RCSfile: p_sight.c,v $
//** $Revision: 1.1 $
//** $Date: 95/05/11 00:22:50 $
//** $Author: bgokey $
//**
//**************************************************************************

#include <assert.h>

#include "doomdef.h"
#include "i_system.h"
#include "p_local.h"
#include "m_random.h"
#include "m_bbox.h"
#include "templates.h"
#include "p_lnspec.h"

// State.
#include "r_state.h"

#include "stats.h"

static FRandom pr_botchecksight ("BotCheckSight");
static FRandom pr_checksight ("CheckSight");

static cycle_t SightCycles, MaxSightCycles;

//
// P_CheckSight
//
// killough 4/19/98:
// Convert LOS info to struct for reentrancy and efficiency of data locality

struct los_t
{
	fixed_t sightzstart, t2x, t2y;   // eye z of looker
	divline_t strace;                // from t1 to t2
	fixed_t topslope, bottomslope;   // slopes to top and bottom of target
	int SeePastBlockEverything;
	int SeePastShootableLines;

	bool CrossBSPNode (const void *node);
	bool CrossSubsector (const subsector_t *ssec);
};

//
// P_DivlineSide
// Returns side 0 (front), 1 (back), or 2 (on).
//

static int P_DivlineSide (fixed_t x, fixed_t y, const divline_t *line)
{
	fixed_t lala = DMulScale32 (y-line->y, line->dx, line->x-x, line->dy);
	if (lala > 0)
	{
		return 1;
	}
	else if (lala < 0)
	{
		return 0;
	}
	else
	{
		return 2;
	}
}

//
// P_CrossSubsector
// Returns true if strace crosses the given subsector successfully.
//
// killough 4/19/98: made static and cleaned up

bool los_t::CrossSubsector (const subsector_t *ssec)
{
	line_t *line;
	divline_t divl;
	fixed_t opentop, openbottom;
	const vertex_t *v1,*v2;
	fixed_t frac;
	const seg_t *seg;
	int count;

	// [RH] check polyobject lines
	if (ssec->poly != NULL)
	{
		for (count = ssec->poly->numsegs; --count >= 0; )
		{
			seg = ssec->poly->segs[count];
			line = seg->linedef;

			// already checked this line?
			if (line->validcount == validcount)
				continue;

			line->validcount = validcount;

			v1 = line->v1;
			v2 = line->v2;

			// line isn't crossed?
			if (P_DivlineSide(v1->x, v1->y, &strace) ==
				P_DivlineSide(v2->x, v2->y, &strace))
				continue;

			divl.dx = v2->x - (divl.x = v1->x);
			divl.dy = v2->y - (divl.y = v1->y);

			// line isn't crossed?
			if (P_DivlineSide(strace.x, strace.y, &divl) ==
				P_DivlineSide(t2x, t2y, &divl))
				continue;

			// stop because it is not two sided anyway
			if (!(line->flags & ML_TWOSIDED) || !seg->backsector)
				return false;

			// [RH] don't see past block everything lines
			if (line->flags & ML_BLOCKEVERYTHING)
			{
				if (!SeePastBlockEverything)
				{
					return false;
				}
				if (SeePastShootableLines &&
					(GET_SPAC(line->flags) != SPAC_IMPACT ||
					(line->special != ACS_Execute && line->special != ACS_ExecuteAlways)) ||
					(line->args[1] != 0 && line->args[1] != level.levelnum))
				{
					// Pretend the other side is invisible if this is not an impact line
					// or it does not run a script on the current map. Used to prevent
					// monsters from trying to attack through a block everything line
					// unless there's a chance their attack will make it nonblocking.
					return false;
				}
			}

			// 2-sided polyobjects cannot have height differences
		}
	}

	// check lines
	seg = segs + ssec->firstline;
	for (count = ssec->numlines; --count >= 0; seg++)
	{
		line = seg->linedef;

		// already checked other side?
		if (line->validcount == validcount)
			continue;

		line->validcount = validcount;

		v1 = line->v1;
		v2 = line->v2;

		// line isn't crossed?
		if (P_DivlineSide(v1->x, v1->y, &strace) ==
			P_DivlineSide(v2->x, v2->y, &strace))
			continue;

		divl.dx = v2->x - (divl.x = v1->x);
		divl.dy = v2->y - (divl.y = v1->y);

		// line isn't crossed?
		if (P_DivlineSide(strace.x, strace.y, &divl) ==
			P_DivlineSide(t2x, t2y, &divl))
			continue;

		// stop because it is not two sided anyway
		if (!(line->flags & ML_TWOSIDED) || !seg->backsector)
			return false;

		// [RH] don't see past block everything lines
		if (line->flags & ML_BLOCKEVERYTHING)
		{
			if (!SeePastBlockEverything)
			{
				return false;
			}
			if (SeePastShootableLines &&
				(GET_SPAC(line->flags) != SPAC_IMPACT ||
				(line->special != ACS_Execute && line->special != ACS_ExecuteAlways)) ||
				(line->args[1] != 0 && line->args[1] != level.levelnum))
			{
				// Pretend the other side is invisible if this is not an impact line
				// or it does not run a script on the current map. Used to prevent
				// monsters from trying to attack through a block everything line
				// unless there's a chance their attack will make it nonblocking.
				return false;
			}
		}

		// crosses a two sided line

		frac = P_InterceptVector (&strace, &divl);

		fixed_t hx = strace.x + FixedMul (strace.dx, frac);
		fixed_t hy = strace.y + FixedMul (strace.dy, frac);

		fixed_t bf = seg->backsector->floorplane.ZatPoint (hx, hy);
		fixed_t bc = seg->backsector->ceilingplane.ZatPoint (hx, hy);
		fixed_t ff = seg->frontsector->floorplane.ZatPoint (hx, hy);
		fixed_t fc = seg->frontsector->ceilingplane.ZatPoint (hx, hy);

		// no wall to block sight with?
		if (ff == bf && fc == bc)
			continue;

		// possible occluder
		// because of ceiling height differences
		opentop = MIN (fc, bc);

		// because of floor height differences
		openbottom = MAX (ff, bf);

		// quick test for totally closed doors
		if (openbottom >= opentop)
			return false;				// stop

		if (ff != bf)
		{
			fixed_t slope = FixedDiv (openbottom - sightzstart, frac);
			if (slope > bottomslope)
				bottomslope = slope;
		}

		if (fc != bc)
		{
			fixed_t slope = FixedDiv (opentop - sightzstart, frac);
			if (slope < topslope)
				topslope = slope;
		}

		if (topslope <= bottomslope)
			return false;				// stop
	}
	// passed the subsector ok
	return true;
}

//
// P_CrossBSPNode
// Returns true
//  if strace crosses the given node successfully.
//
// killough 4/20/98: rewritten to remove tail recursion, clean up, and optimize

bool los_t::CrossBSPNode (const void *node)
{
	if (numnodes == 0)
	{
		return CrossSubsector (subsectors);
	}
	while (!((size_t)node & 1))
	{
		const node_t *bsp = (const node_t *)node;
		int side = P_DivlineSide (strace.x, strace.y, (divline_t *)bsp) & 1;
		if (side == P_DivlineSide (t2x, t2y, (divline_t *)bsp))
		{
			node = bsp->children[side]; // doesn't touch the other side
		}
		else
		{			// the partition plane is crossed here
			if (!CrossBSPNode (bsp->children[side]))
			{
				return false;		// cross the starting side
			}
			else
			{
				node = bsp->children[side^1];  // cross the ending side
			}
		}
	}
	return CrossSubsector ((subsector_t *)((BYTE *)node - 1));
}

/*
=====================
=
= P_CheckSight
=
= Returns true if a straight line between t1 and t2 is unobstructed
= look from eyes of t1 to any part of t2
=
= killough 4/20/98: cleaned up, made to use new LOS struct
=
=====================
*/

bool P_CheckSight (const AActor *t1, const AActor *t2, int flags)
{
	clock (SightCycles);

	bool res;

#ifdef _DEBUG
	assert (t1 != NULL);
	assert (t2 != NULL);
#else
	if (t1 == NULL || t2 == NULL)
	{
		return false;
	}
#endif

	const sector_t *s1 = t1->Sector;
	const sector_t *s2 = t2->Sector;
	int pnum = int(s1 - sectors) * numsectors + int(s2 - sectors);

//
// check for trivial rejection
//
	if (rejectmatrix != NULL &&
		(rejectmatrix[pnum>>3] & (1 << (pnum & 7))))
	{
		res = false;			// can't possibly be connected
		goto done;
	}

//
// check precisely
//
	// [RH] Andy Baker's stealth monsters:
	// Cannot see an invisible object
	if ((flags & 1) == 0 &&
		(t2->RenderStyle == STYLE_None ||
		 (t2->RenderStyle >= STYLE_Translucent && t2->alpha == 0) ||
		 (t2->renderflags & RF_INVISIBLE)))
	{ // small chance of an attack being made anyway
		if ((bglobal.m_Thinking ? pr_botchecksight() : pr_checksight()) > 50)
		{
			res = false;
			goto done;
		}
	}

	// killough 4/19/98: make fake floors and ceilings block monster view

	if ((s1->heightsec && !(s1->heightsec->MoreFlags & SECF_IGNOREHEIGHTSEC) &&
		((t1->z + t1->height <= s1->heightsec->floorplane.ZatPoint (t1->x, t1->y) &&
		  t2->z >= s1->heightsec->floorplane.ZatPoint (t2->x, t2->y)) ||
		 (t1->z >= s1->heightsec->ceilingplane.ZatPoint (t1->x, t1->y) &&
		  t2->z + t1->height <= s1->heightsec->ceilingplane.ZatPoint (t2->x, t2->y))))
		||
		(s2->heightsec && !(s2->heightsec->MoreFlags & SECF_IGNOREHEIGHTSEC) &&
		 ((t2->z + t2->height <= s2->heightsec->floorplane.ZatPoint (t2->x, t2->y) &&
		   t1->z >= s2->heightsec->floorplane.ZatPoint (t1->x, t1->y)) ||
		  (t2->z >= s2->heightsec->ceilingplane.ZatPoint (t2->x, t2->y) &&
		   t1->z + t2->height <= s2->heightsec->ceilingplane.ZatPoint (t1->x, t1->y)))))
	{
		res = false;
		goto done;
	}

	// An unobstructed LOS is possible.
	// Now look from eyes of t1 to any part of t2.

	validcount++;

	los_t los;

	los.sightzstart = t1->z + t1->height - (t1->height>>2);
	los.bottomslope = t2->z - los.sightzstart;
	los.topslope = los.bottomslope + t2->height;
	los.strace.x = t1->x;
	los.strace.y = t1->y;
	los.strace.dx = t2->x - t1->x;
	los.strace.dy = t2->y - t1->y;
	los.t2x = t2->x;
	los.t2y = t2->y;
	los.SeePastBlockEverything = flags & 6;
	los.SeePastShootableLines = flags & 4;

	res = los.CrossBSPNode (&nodes[numnodes-1]);

done:
	unclock (SightCycles);
	return res;
}

ADD_STAT (sight, out)
{
	sprintf (out, "%04.1f ms (%04.1f max)\n",
		(double)SightCycles * 1000 * SecondsPerCycle,
		(double)MaxSightCycles * 1000 * SecondsPerCycle);
}

void P_ResetSightCounters (bool full)
{
	if (full)
	{
		MaxSightCycles = 0;
	}
	if (SightCycles > MaxSightCycles)
	{
		MaxSightCycles = SightCycles;
	}
	SightCycles = 0;
}
