// Emacs style mode select	 -*- C++ -*- 
//-----------------------------------------------------------------------------
//
// $Id:$
//
// Copyright (C) 1993-1996 by id Software, Inc.
//
// This source is available for distribution and/or modification
// only under the terms of the DOOM Source Code License as
// published by id Software. All rights reserved.
//
// The source is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// FITNESS FOR A PARTICULAR PURPOSE. See the DOOM Source Code License
// for more details.
//
// DESCRIPTION:
//		Thing frame/state LUT,
//		generated by multigen utilitiy.
//		This one is the original DOOM version, preserved.
//
//-----------------------------------------------------------------------------

#ifndef __INFO_H__
#define __INFO_H__

#include "dobject.h"
#include "dthinker.h"
#include "farchive.h"

struct FState
{
	union
	{
		char name[4];
		int index;
	} sprite;
	BYTE		frame;
	WORD		fullbright;
	SWORD		tics;
	actionf_t 	action;
	FState		*nextstate;
	int			misc1, misc2;
};

FArchive &operator<< (FArchive &arc, FState *&state);

#if _MSC_VER
#define _S__COMMON_(spr) \
	{ {{(char)(#@spr>>24),(char)(#@spr>>16),(char)(#@spr>>8),(char)#@spr}}
#else
#define _S__COMMON_(spr) \
	{ {#spr}
#endif

#define _S_N_COMMON_(spr,frm,tic,cmd,next) \
	_S__COMMON_(spr), (frm) - 'A', 0, tic, {cmd}, next

#define _S_B_COMMON_(spr,frm,tic,cmd,next) \
	_S__COMMON_(spr), (frm) - 'A', RF_FULLBRIGHT, tic, {cmd}, next

/* <winbase.h> #defines its own, completely unrelated S_NORMAL.
 * Since winbase.h will only be included in Win32-specific files that
 * don't define any actors, we can safely avoid defining it here.
 */

#ifndef S_NORMAL
#define S_NORMAL(spr,frm,tic,cmd,next) \
	_S_N_COMMON_(spr,frm,tic,cmd,next), 0, 0}
#endif

#define S_BRIGHT(spr,frm,tic,cmd,next) \
	_S_B_COMMON_(spr,frm,tic,cmd,next), 0, 0}

#define S_NORMAL2(spr,frm,tic,cmd,next,m1,m2) \
	_S_N_COMMON_(spr,frm,tic,cmd,next), m1, m2}

#define S_BRIGHT2(spr,frm,tic,cmd,next,m1,m2) \
	_S_B_COMMON_(spr,frm,tic,cmd,next), m1, m2}


#ifndef EGAMETYPE
#define EGAMETYPE
enum EGameType
{
	GAME_Any	 = 0,
	GAME_Doom	 = 1,
	GAME_Heretic = 2,
	GAME_Hexen	 = 4,
	GAME_Raven	 = 6
};
#endif

enum
{
	ADEFTYPE_Byte		= 0,
	ADEFTYPE_FixedMul	= 64,		// one byte, multiplied by FRACUNIT
	ADEFTYPE_Word		= 128,
	ADEFTYPE_Long		= 192,
	ADEFTYPE_MASK		= 192,

	// These first properties are always strings
	ADEF_SeeSound = 1,
	ADEF_AttackSound,
	ADEF_PainSound,
	ADEF_DeathSound,
	ADEF_ActiveSound,
	ADEF_LastString = ADEF_ActiveSound,

	// The rest of the properties use their type field (upper 2 bits)
	ADEF_XScale,
	ADEF_YScale,
	ADEF_SpawnHealth,
	ADEF_ReactionTime,
	ADEF_PainChance,
	ADEF_Speed,
	ADEF_Radius,
	ADEF_Height,
	ADEF_Mass,
	ADEF_Damage,
	ADEF_Flags,			// Use these flags exactly
	ADEF_Flags2,		// "
	ADEF_Flags3,		// "
	ADEF_FlagsSet,		// Or these flags with previous
	ADEF_Flags2Set,		// "
	ADEF_Flags3Set,		// "
	ADEF_FlagsClear,	// Clear these flags from previous
	ADEF_Flags2Clear,	// "
	ADEF_Flags3Clear,	// "
	ADEF_Alpha,
	ADEF_RenderStyle,
	ADEF_RenderFlags,

	ADEF_SpawnState,
	ADEF_SeeState,
	ADEF_PainState,
	ADEF_MeleeState,
	ADEF_MissileState,
	ADEF_CrashState,
	ADEF_DeathState,
	ADEF_XDeathState,
	ADEF_BDeathState,
	ADEF_IDeathState,
	ADEF_RaiseState,

	// The following are not properties but effect how the list is parsed
	ADEF_FirstCommand,
	ADEF_LimitGame = ADEF_FirstCommand,
	ADEF_SkipSuper,		// Take defaults from AActor instead of superclass(es)
	ADEF_StateBase,		// Use states not owned by this actor

	ADEF_EOL = 0		// End Of List
};

#if _MSC_VER
#pragma warning(disable:4200)	// nonstandard extension used : zero-sized array in struct/union
#endif

struct FActorInfo
{
	static void StaticInit ();
	static void StaticGameSet ();
	static void StaticSpeedSet ();

	void BuildDefaults ();
	void ApplyDefaults (BYTE *defaults);

	TypeInfo *Class;
	FState *OwnedStates;
	BYTE *Defaults;
	int NumOwnedStates;
	BYTE GameFilter;
	BYTE SpawnID;
	SWORD DoomEdNum;

	// Followed by a 0-terminated list of default properties
	BYTE DefaultList[];
};

#if _MSC_VER
#pragma warning(default:4200)
#endif

class FDoomEdMap
{
public:
	const TypeInfo *FindType (int doomednum) const;
	void AddType (int doomednum, const TypeInfo *type);
	void DelType (int doomednum);
	void Empty ();

private:
	enum { DOOMED_HASHSIZE = 256 };

	struct FDoomEdEntry
	{
		FDoomEdEntry *HashNext;
		const TypeInfo *Type;
		int DoomEdNum;
	};

	static FDoomEdEntry *DoomEdHash[DOOMED_HASHSIZE];
};

extern FDoomEdMap DoomEdMap;

#include "infomacros.h"

#endif	// __INFO_H__
