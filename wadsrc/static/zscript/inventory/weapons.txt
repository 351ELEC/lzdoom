class Weapon : StateProvider native
{
	enum EFireMode
	{
		PrimaryFire,
		AltFire,
		EitherFire
	};

	native uint WeaponFlags;
	native class<Ammo> AmmoType1, AmmoType2;		// Types of ammo used by this weapon
	native int AmmoGive1, AmmoGive2;				// Amount of each ammo to get when picking up weapon
	native int MinAmmo1, MinAmmo2;					// Minimum ammo needed to switch to this weapon
	native int AmmoUse1, AmmoUse2;					// How much ammo to use with each shot
	native int Kickback;
	native float YAdjust;							// For viewing the weapon fullscreen (visual only so no need to be a double)
	native sound UpSound, ReadySound;				// Sounds when coming up and idle
	native class<Weapon> SisterWeaponType;			// Another weapon to pick up with this one
	native class<Actor> ProjectileType;				// Projectile used by primary attack
	native class<Actor> AltProjectileType;			// Projectile used by alternate attack
	native int SelectionOrder;						// Lower-numbered weapons get picked first
	native int MinSelAmmo1, MinSelAmmo2;			// Ignore in BestWeapon() if inadequate ammo
	native double MoveCombatDist;					// Used by bots, but do they *really* need it?
	native int ReloadCounter;						// For A_CheckForReload
	native int BobStyle;							// [XA] Bobbing style. Defines type of bobbing (e.g. Normal, Alpha)  (visual only so no need to be a double)
	native float BobSpeed;							// [XA] Bobbing speed. Defines how quickly a weapon bobs.
	native float BobRangeX, BobRangeY;				// [XA] Bobbing range. Defines how far a weapon bobs in either direction.
	native Ammo Ammo1, Ammo2;						// In-inventory instance variables
	native Weapon SisterWeapon;
	native float FOVScale;
	native int Crosshair;							// 0 to use player's crosshair
	native bool GivenAsMorphWeapon;
	native bool bAltFire;							// Set when this weapon's alternate fire is used.
	native readonly bool bDehAmmo;

	Default
	{
		Inventory.PickupSound "misc/w_pkup";
		Weapon.DefaultKickback;
		Weapon.BobSpeed 1.0;
		Weapon.BobRangeX 1.0;
		Weapon.BobRangeY 1.0;
		+WEAPONSPAWN
		DefaultStateUsage SUF_ACTOR|SUF_OVERLAY|SUF_WEAPON;
	}
	States
	{
	LightDone:
		SHTG E 0 A_Light0;
		Stop;
	}
	
	native bool CheckAmmo(int fireMode, bool autoSwitch, bool requireAmmo = false, int ammocount = -1);
	native bool DepleteAmmo(bool altFire, bool checkEnough = true, int ammouse = -1);
	native virtual void EndPowerup();
	
	virtual State GetReadyState ()
	{
		return FindState('Ready');
	}
	
	virtual State GetUpState ()
	{
		return FindState('Select');
	}

	virtual State GetDownState ()
	{
		return FindState('Deselect');
	}

	virtual State GetAtkState (bool hold)
	{
		State s = null;
		if (hold) s = FindState('Hold');
		if (s == null) s = FindState('Fire');
		return s;
	}
	
	virtual State GetAltAtkState (bool hold)
	{
		State s = null;
		if (hold) s = FindState('AltHold');
		if (s == null) s = FindState('AltFire');
		return s;
	}
	
	action void A_GunFlash(statelabel flashlabel = null, int flags = 0)
	{
		let player = player;

		if (null == player || player.ReadyWeapon == null)
		{
			return;
		}
		if (!(flags & GFF_NOEXTCHANGE))
		{
			player.mo.PlayAttacking2 ();
		}
		if (flashlabel == null)
		{
			if (player.ReadyWeapon.bAltFire)
			{
				flashlabel = 'AltFlash';
			}
			if (flashlabel == null)
			{
				flashlabel = 'Flash';
			}
		}
		player.SetPsprite(PSP_FLASH, player.ReadyWeapon.FindState(flashlabel));
	}
	
	//---------------------------------------------------------------------------
	//
	// PROC A_Lower
	//
	//---------------------------------------------------------------------------

	action void A_Lower(int lowerspeed = 6)
	{
		let player = player;

		if (null == player)
		{
			return;
		}
		if (null == player.ReadyWeapon)
		{
			player.BringUpWeapon();
			return;
		}
		let psp = player.GetPSprite(PSP_WEAPON);
		if (player.morphTics || player.cheats & CF_INSTANTWEAPSWITCH)
		{
			psp.y = WEAPONBOTTOM;
		}
		else
		{
			psp.y += lowerspeed;
		}
		if (psp.y < WEAPONBOTTOM)
		{ // Not lowered all the way yet
			return;
		}
		if (player.playerstate == PST_DEAD)
		{ // Player is dead, so don't bring up a pending weapon
			// Player is dead, so keep the weapon off screen
			player.SetPsprite(PSP_FLASH, null);
			psp.SetState(player.ReadyWeapon.FindState('DeadLowered'));
			return;
		}
		// [RH] Clear the flash state. Only needed for Strife.
		player.SetPsprite(PSP_FLASH, null);
		player.BringUpWeapon ();
		return;
	}

	//---------------------------------------------------------------------------
	//
	// PROC A_Raise
	//
	//---------------------------------------------------------------------------

	action void A_Raise(int raisespeed = 6)
	{
		let player = player;

		if (null == player)
		{
			return;
		}
		if (player.PendingWeapon != WP_NOCHANGE)
		{
			player.DropWeapon();
			return;
		}
		if (player.ReadyWeapon == null)
		{
			return;
		}
		let psp = player.GetPSprite(PSP_WEAPON);
		psp.y -= raisespeed;
		if (psp.y > WEAPONTOP)
		{ // Not raised all the way yet
			return;
		}
		psp.y = WEAPONTOP;
		psp.SetState(player.ReadyWeapon.GetReadyState());
		return;
	}

	//---------------------------------------------------------------------------
	//
	// PROC A_CheckReload
	//
	// Present in Doom, but unused. Also present in Strife, and actually used.
	//
	//---------------------------------------------------------------------------

	action void A_CheckReload()
	{
		let player = self.player;
		if (player != NULL)
		{
			player.ReadyWeapon.CheckAmmo (player.ReadyWeapon.bAltFire ? Weapon.AltFire : Weapon.PrimaryFire, true);
		}
	}
	
	
	native action void A_ZoomFactor(double scale = 1, int flags = 0);
	native action void A_SetCrosshair(int xhair);
	const ZOOM_INSTANT = 1;
	const ZOOM_NOSCALETURNING = 2;
	
}

class WeaponGiver : Weapon native
{
	
	native double DropAmmoFactor;
	
	Default
	{
		Weapon.AmmoGive1 -1;
		Weapon.AmmoGive2 -1;
	}
}

struct WeaponSlots native
{
	native bool, int, int LocateWeapon(class<Weapon> weap);
}