
class StateProvider : Inventory native
{
	action native state A_JumpIfNoAmmo(statelabel label);
	action native void A_CustomPunch(int damage, bool norandom = false, int flags = CPF_USEAMMO, class<Actor> pufftype = "BulletPuff", double range = 0, double lifesteal = 0, int lifestealmax = 0, class<BasicArmorBonus> armorbonustype = "ArmorBonus", sound MeleeSound = 0, sound MissSound = "");
	action native void A_RailAttack(int damage, int spawnofs_xy = 0, bool useammo = true, color color1 = 0, color color2 = 0, int flags = 0, double maxdiff = 0, class<Actor> pufftype = "BulletPuff", double spread_xy = 0, double spread_z = 0, double range = 0, int duration = 0, double sparsity = 1.0, double driftspeed = 1.0, class<Actor> spawnclass = "none", double spawnofs_z = 0, int spiraloffset = 270, int limit = 0);
	action native void A_WeaponReady(int flags = 0);

	//---------------------------------------------------------------------------
	//
	//
	//
	//---------------------------------------------------------------------------

	action void A_FireBullets(double spread_xy, double spread_z, int numbullets, int damageperbullet, class<Actor> pufftype = "BulletPuff", int flags = 1, double range = 0, class<Actor> missile = null, double Spawnheight = 32, double Spawnofs_xy = 0)
	{
		let player = player;
		if (!player) return;

		let pawn = PlayerPawn(self);
		let weapon = player.ReadyWeapon;

		int i;
		double bangle;
		double bslope = 0.;
		int laflags = (flags & FBF_NORANDOMPUFFZ)? LAF_NORANDOMPUFFZ : 0;

		if ((flags & FBF_USEAMMO) && weapon &&  stateinfo != null && stateinfo.mStateType == STATE_Psprite)
		{
			if (!weapon.DepleteAmmo(weapon.bAltFire, true))
				return;	// out of ammo
		}
		
		if (range == 0)	range = PLAYERMISSILERANGE;

		if (!(flags & FBF_NOFLASH)) pawn.PlayAttacking2 ();

		if (!(flags & FBF_NOPITCH)) bslope = BulletSlope();
		bangle = Angle;

		if (pufftype == NULL) pufftype = 'BulletPuff';

		if (weapon != NULL)
		{
			A_PlaySound(weapon.AttackSound, CHAN_WEAPON);
		}

		if ((numbullets == 1 && !player.refire) || numbullets == 0)
		{
			int damage = damageperbullet;

			if (!(flags & FBF_NORANDOM))
				damage *= random[cabullet](1, 3);

			let puff = LineAttack(bangle, range, bslope, damage, 'Hitscan', pufftype, laflags);

			if (missile != null)
			{
				bool temp = false;
				double ang = Angle - 90;
				Vector2 ofs = AngleToVector(Spawnofs_xy);
				Actor proj = SpawnPlayerMissile(missile, bangle, ofs.X, ofs.Y, Spawnheight);
				if (proj)
				{
					if (!puff)
					{
						temp = true;
						puff = LineAttack(bangle, range, bslope, 0, 'Hitscan', pufftype, laflags | LAF_NOINTERACT);
					}
					AimBulletMissile(proj, puff, flags, temp, false);
				}
			}
		}
		else 
		{
			if (numbullets < 0)
				numbullets = 1;
			for (i = 0; i < numbullets; i++)
			{
				double pangle = bangle;
				double slope = bslope;

				if (flags & FBF_EXPLICITANGLE)
				{
					pangle += spread_xy;
					slope += spread_z;
				}
				else
				{
					pangle += spread_xy * Random2[cabullet]() / 255.;
					slope += spread_z * Random2[cabullet]() / 255.;
				}

				int damage = damageperbullet;

				if (!(flags & FBF_NORANDOM))
					damage *= random[cabullet](1, 3);

				let puff = LineAttack(pangle, range, slope, damage, 'Hitscan', pufftype, laflags);

				if (missile != null)
				{
					bool temp = false;
					double ang = Angle - 90;
					Vector2 ofs = AngleToVector(Spawnofs_xy);
					Actor proj = SpawnPlayerMissile(missile, bangle, ofs.X, ofs.Y, Spawnheight);
					if (proj)
					{
						if (!puff)
						{
							temp = true;
							puff = LineAttack(bangle, range, bslope, 0, 'Hitscan', pufftype, laflags | LAF_NOINTERACT);
						}
						AimBulletMissile(proj, puff, flags, temp, false);
					}
				}
			}
		}
	}


	//==========================================================================
	//
	// A_FireProjectile
	//
	//==========================================================================

	action Actor A_FireProjectile(class<Actor> ti, double spawnangle = 0, bool useammo = true, double spawnofs_xy = 0, double spawnheight = 0, int flags = 0, double pitch = 0)
	{
		let player = self.player;
		if (!player) return null;

		let weapon = player.ReadyWeapon;

		FTranslatedLineTarget t;

			// Only use ammo if called from a weapon
		if (useammo && weapon && stateinfo != null && stateinfo.mStateType == STATE_Psprite)
		{
			if (!weapon.DepleteAmmo(weapon.bAltFire, true))
				return null;	// out of ammo
		}

		if (ti) 
		{
			double ang = Angle - 90;
			Vector2 ofs = AngleToVector(Spawnofs_xy);
			double shootangle = Angle;

			if (flags & FPF_AIMATANGLE) shootangle += spawnangle;

			// Temporarily adjusts the pitch
			double saved_player_pitch = self.Pitch;
			self.Pitch += pitch;
			let misl = SpawnPlayerMissile (ti, shootangle, ofs.X, ofs.Y, spawnheight, t, NULL, false, (flags & FPF_NOAUTOAIM) != 0);
			self.Pitch = saved_player_pitch;

			// automatic handling of seeker missiles
			if (misl)
			{
				if (flags & FPF_TRANSFERTRANSLATION)
					misl.Translation = Translation;
				if (t.linetarget && !t.unlinked && misl.bSeekerMissile)
					misl.tracer = t.linetarget;
				if (!(flags & FPF_AIMATANGLE))
				{
					// This original implementation is to aim straight ahead and then offset
					// the angle from the resulting direction. 
					misl.Angle += spawnangle;
					misl.VelFromAngle(misl.Vel.XY.Length());
				}
			}
			return misl;
		}
		return null;
	}

	
	//---------------------------------------------------------------------------
	//
	// PROC A_ReFire
	//
	// The player can re-fire the weapon without lowering it entirely.
	//
	//---------------------------------------------------------------------------

	action void A_ReFire(statelabel flash = null)
	{
		let player = player;
		bool pending;

		if (NULL == player)
		{
			return;
		}
		pending = player.PendingWeapon != WP_NOCHANGE && (player.WeaponState & WF_REFIRESWITCHOK);
		if ((player.cmd.buttons & BT_ATTACK)
			&& !player.ReadyWeapon.bAltFire && !pending && player.health > 0)
		{
			player.refire++;
			player.mo.FireWeapon(ResolveState(flash));
		}
		else if ((player.cmd.buttons & BT_ALTATTACK)
			&& player.ReadyWeapon.bAltFire && !pending && player.health > 0)
		{
			player.refire++;
			player.mo.FireWeaponAlt(ResolveState(flash));
		}
		else
		{
			player.refire = 0;
			player.ReadyWeapon.CheckAmmo (player.ReadyWeapon.bAltFire? Weapon.AltFire : Weapon.PrimaryFire, true);
		}
	}
	
	action native state A_CheckForReload(int counter, statelabel label, bool dontincrement = false);
	action native void A_ResetReloadCounter();

	action void A_ClearReFire()
	{
		if (NULL != player)	player.refire = 0;
	}
}

class CustomInventory : StateProvider
{
	Default
	{
		DefaultStateUsage SUF_ACTOR|SUF_OVERLAY|SUF_ITEM;
	}
	
	//---------------------------------------------------------------------------
	//
	//
	//---------------------------------------------------------------------------

	// This is only here, because these functions were originally exported on Inventory, despite only working for weapons, so this is here to satisfy some potential old mods having called it through CustomInventory.
	deprecated("2.3") action void A_GunFlash(statelabel flash = null, int flags = 0) {}
	deprecated("2.3") action void A_Lower() {}
	deprecated("2.3") action void A_Raise() {}
	deprecated("2.3") action void A_CheckReload() {}
	native bool CallStateChain (Actor actor, State state);
		
	//===========================================================================
	//
	// ACustomInventory :: SpecialDropAction
	//
	//===========================================================================

	override bool SpecialDropAction (Actor dropper)
	{
		return CallStateChain (dropper, FindState('Drop'));
	}

	//===========================================================================
	//
	// ACustomInventory :: Use
	//
	//===========================================================================

	override bool Use (bool pickup)
	{
		return CallStateChain (Owner, FindState('Use'));
	}

	//===========================================================================
	//
	// ACustomInventory :: TryPickup
	//
	//===========================================================================

	override bool TryPickup (in out Actor toucher)
	{
		let pickupstate = FindState('Pickup');
		bool useok = CallStateChain (toucher, pickupstate);
		if ((useok || pickupstate == NULL) && FindState('Use') != NULL)
		{
			useok = Super.TryPickup (toucher);
		}
		else if (useok)
		{
			GoAwayAndDie();
		}
		return useok;
	}
}
